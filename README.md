# 2210

# 1002

#  186A Brick   diff 4

解答遷移 AC

計 01:23

備考

なし



# ARC122B ☆  Insurance   diff 729　　

解答遷移 AC

計 23:00

備考

➀ 思考

さっぱりわからない。実験によってそれぞれ x= Ai/2b となる xで損失が極小になることはわかったので、B問題だし、極小値へのベクトルが平衡になる場所 x が全体を最小化するってことで解答できそうだと判断(全く根拠なし)。あとはN が 偶数の場合だけ、平衡地点が2か所あるのでそれを比較していい方をだせば完了だな AC

* この考えが正しいとしても、Aの中央地点を Ai, Aj とすると、 偶数のときは Ai < x <Aj でベクトルは平衡になるが、どちらかに一致する場合にはむしろ平衡ならないと気が付く。本当にたまたまのACである。ABCと勘違いしたためにできただけ

➁ 解法

Nx - Σmin(2x,Ai) のグラフの傾きを考えると、Nが偶数の場合、例えばN=4のときは A2/2 < x < A3/2 において傾きが0になって極小値をとることがわかる( min()が含まれるためなめらかではないので、A2/2 および A3/2 の前後で傾きが急変する) Nが奇数の場合傾きが0になることはないが、例えば N=3 の場合 A1/2 < x < A2/2 において 傾き -1 , A/2 < x <A3/2  において傾き 1になるので　その中間の A2/2 において 極小値をとる。

したがって、x = A[N//2] で損失は最小になる。 ( Nが偶数のときは A[N//2-1] ～ A[N//2] を満たす任意の実数がxとして成立する)


中央値とindex番号のズレに注意



# 182D Wandering  diff 708

解答遷移 AC

計 27:57

備考

➀ 思考

途中の情報が必要なので、塁積和をとって途中の情報を消したりはできない。[ 現在地 , 最高到達点 ] と2次元で保存しながら更新していくのがよいと考えた。あとはどうやってこれらを更新していくかで、現在地から次の現在地まで行くのは累積和で簡単に求まる。よって最高到達点の更新方法だが、これには場所だけでなく、進み方の情報も必要であることに注目した。例えば 現在の最高の進み方が +5 だとしたら現在地 + 5 が最高到達点であれば、最高到達地点を更新する。また、進み方も随時更新され、累積和が最高の進み方を超えれば更新していけばよい。あとは更新の順番に気を付けて実装してAC


実際には20分ぐらいで完了できていたのだが、手計算による検算がうまくいかず提出までに時間がかかってしまった。




# 平衡二分探索木(順序付き集合)　ver python の勉強

C++には存在し、pythonには存在しないデータ構造 std::set のpython版 Sortedsetを扱う

・概要

https://qiita.com/tatyam/items/492c70ac4c955c055602

・関数など

https://github.com/tatyam-prime/SortedSet


簡単に言えば、リストに追加した後、通常よりも高速にsortしてくれるデータ構造である。


S=Sorted(イテラブル)で初期化することで扱える。基本操作はリストと同じ。S[index]で index番号にアクセスして要素を取り出すことができる

・ add(x)

要素の追加。set同様、重複していれば追加されない

・ index(x)

x 未満の要素の数を出力できる。






# ☆ 217C  Cutting Woods  diff 802

➀ 思考

長さ12の木材を位置7で切断したい場合、0,1,..,6  8,9,..,12 の2グループが生成される。これは最初に 0 始まり 長さ12 の木材を持っている状態で、0 始まり長さ7 , 8(7+1) 始まり長さ 5(12-7)の2グループが生成されたと考えられる。したがって、始点と長さを記憶していけばこの問題を解答できると考えたのだが、この次に 3 の位置で分断しようとした場合 位置3 がどのグループに含まれるかわからなければいけない。そのためには例えば始点を管理して二分探索するなどの方法が考えられるが、これにはこの操作を行う前に sort 処理を行わねばならず、全体で O(NlogN) かかるのでとてもクエリ全てをさばききれない。この 位置x がどの始点からはじまるグループに含まれるかのボトルネックを解消するには、おそらくこの処理に適したデータ構造が必要だと感じ、それを知らない今は降参するしかないと判断した。

結局 平衡二分探索木が必要だったので、思考自体は◎


➁ 解法

7の木材の位置3で分断する際、 [0,3] [4,4] と考えたが、実は切れ込みの位置(位置0,7を含む) を管理さえすれば長さを管理しなくても、前後の要素の差でこれが求まる。　例えば 0,3,7 のとき、位置2を含む集合の長さは 3-0 で 3とわかるし、 位置5では 7-3=4 で長さが4とわかる。


③ 入力改善   input = sys.std.readline

仕組みはわからないが、これで提出時間が半分になった。これを宣言するだけであとは通常通りなので、大量の一行入力(for で処理するやつ) の場合は脳死で使った方が良さそう

https://qiita.com/kyuna/items/8ee8916c2f4e36321a1c




#  253c  Max - Min Query      diff  518

解答遷移 AC

計 17:00

備考

➀  思考

query3 に際して、最大値と最小値にアクセスする必要があるが、挿入される値は単調に増加したり減少したりしないので、今持っている値すべての順番を記憶しておかないと、高速なアクセスができない。挿入毎にsortするわけにもいかないので SortSet を使用することにした。しかし今回は同じ要素を個数を含めて管理しなければならず、SortMultiSetを使うのかなと考えたが、値の削除が面倒そうだったので、個数の管理は別でCollectionで行い、空になったらSortsetから削除するという処理を施せばよいと判断。 


➁　別解

https://atcoder.jp/contests/abc253/submissions/32056927

collections.Counter + 優先度付きキュー　で最先端の個数が0だったら、popする処理を繰り返すことで、最小値、最大値に高速にアクセスする。

注意点は２つ。一つは最小値だけでなく、最大値も必要なので 2つのheap構造が必要になること、また最大値をとりだすために、-xを格納しなければいけないこと。2つ目は、heappush(Xmin,値) として、明確に最小値 heap　と最大値 heapのどちらに値を格納するか示さなければならないこと。SortSetの方がはるかに楽



#  ☆  170D  Not Divisible   diff 1033

降参

備考

➀ 思考

Aiについて約数列挙し、Aにその約数が存在するか 積集合をもちいて判定する処理を考えた。最大計算量は 要素が 10^6 ～ 10^6-2.0* 10^5 のN個のときで、積分することでこれを求めると 1.8* 10^8 でギリギリ通せるかと判断して提出 TLE 。。。

なお普通に重複処理をうまく行えなかったようで　WA も出した。➁で示すように逐一積集合を求めずとも、約数全部をまとめて最後に検出すればこのWAは消えそうだ

➁ 解法

ポイントは以下2点

・列挙するなら 約数　より　倍数

A が B　の約数 ⇔  B は A の倍数 であることを利用する。前者は候補列挙に　√ Ai 回ループが必要で、後者は候補列挙に maxA / Ai 回のループが必要である。 ③でも述べるが、N要素における合計値 つまり積分した値は桁が1つ異なる程度に、後者の方が高速で処理できてしまう。 

・　重複処理

例えば A= 2 8 の場合、 8 のみが条件を満たすためには 列挙する倍数を 2Ai,3Ai...にする必要がある。Aiを含めてしまうとすべての要素が条件を満たしてしまうためである。 

しかしA= 2 2 8 の場合では2を含めないといけない。これを解決するために個数を管理して、最後の検出の際に、倍数候補に含まれない　かつ 重複する要素がないものを数えるようにしたらよいだろう。これならば A= 2,3,3,15,15 に対して 2は候補に含まれずただ一つなので、条件をみたし、3 は候補に含まれないが重複するので省かれる。15は候補に含まれるので数えらない。これで完了できる


③ log N   vs  √ N の積分

後者は結局 N ^ (3/2) になるため N= 10^6 とすると 10^9になるが、 logN はたかだか 10倍する程度なので処理性能が全く異なる。




# 1003  

# アルゴ式 データ構造

# 9-1  二分木の通りがけ順

備考

通りがけ順の定義通りに出力できるようにしたdfsを実装するだけ。具体的には子の情報を index番号か -1 で持つ。例えば [2,-1] で　左側に頂点 2の子を持ち、右側には子を持たないことを示すことにする。あとはふつうにdfsしつつ、右側の子方向に探索を始める前に自分自身の番号を保存すれば完了



# 9-2  二分探索木への挿入 (1)

解答遷移 WA WA AC 

計  09:19

備考

完全にsortされているものだと思っていたが、ルールに従い木を構築し、行きがけ順で出力すれば完了できる

・構築ルール

根頂点から順番に見ていき、
・挿入したいキーが今いる頂点のキー以下である場合は左側の子頂点へ進む
・挿入したいキーが今いる頂点のキーより大きい場合は右側の子頂点へ進む
という動作を繰り返します。
進む先の子頂点が存在しなくなったとき、
その場所に、挿入したいキーをもつ頂点を挿入します。



# 9-3 二分探索木への挿入 (2)






# 222A   Four Digits   diff 5

解答遷移　AC

計 01:08

備考

なし

# 221A Seismic magnitude scales   diff 10

解答遷移　AC

計 01:39

備考

なし

# 222A Find Multiple   diff 14

解答遷移 AC

計 05:19

備考

➀ 解法

B//C * C が B以下の最大のCの倍数なのでこれが A以上であれば出力し、そうでなければ-1 


# 068C  Cat Snuke and a Voyage  diff 609

解答遷移 AC

計 06:39

備考

➀ 思考

bfsで最短距離を調べ上げて、最後にNの最短距離が2かどうか判定




# 106C  To Infinity   diff 441

解答遷移 AC

計　12:47

備考

➀ 思考

5000兆 = 5* 10^18 。　2^60 ≓ 10^18 より 1以外の数がSの先頭にあれば K の値によらず その値が答えになる。したがって考慮すすべきは K が S の先頭に存在する1を示すか否かである。 これはSの先頭に存在する 1　の数をカウントしてその数が K 以上ならば 1が答えになり、それ以外であれば1の次に先頭に存在する数が答えになる処理で完了できると判断。

➁ 改善

K番目までSを前から全探索できないから、カウントするかとなったが、S全部をみる途中にK番目が存在すればそこまで見る処理はできるの。具体的には range(len(Sstr),K) とすればよい。



# 122C  Get AC   diff 700

解答遷移 WA AC

計 30:26

備考

➀　思考

クエリにO(1)で解答しなければいけないので、始点と終点にアクセスするだけでその区間におけるACの数を求めたい。よって尺取り法などではなく累積和を使うのが良さそうだと判断した。あとはSを前から順に探索し、文字列を構成していく。ACになればその地点の個数を+1して、それ以外なら文字列を空にしていく処理を行うことで完了できると判断。WA  →  何が間違っているのか見当もつかないし、愚直解も思いつかないので、ひたすらサンプル作ってテスト　→  運よくたまたますぐにカウントが正しくできていないケースを発見。 文字列が ACにならなければ空にしていたがこれでは AAC　がうまく処理できていなかったのだ。これを修正してAC



➁ 改善

Sの i文字目とi+1文字目で AC になっているか確認すればよい。



③ input.stdin.readline

![image](https://user-images.githubusercontent.com/109026838/193501818-3288c982-2503-4df5-a0fb-dedf78c61137.png)

文字列の場合だけそのまま読み込むと改行文字が含まれてしまうので修正が必要




#  ☆ 261D  Flipping and Bonus  diff 801

降参

備考

➀ 思考

dpだな。ただお金がでかすぎて2次元リストつくれない。それさえできればカウント数を追っていけば解けるのに。。。代案も見つからず降参



➁ 模範思考

i回目投げたとき Z 円持っていたとする。　すると i+1 回目に 裏が出れば Z 円のままであり、表が出ればZ + Xi+1 円になり、さらにここまでの連続表数 k がボーナス値ならばさらに Bk 円追加される。これがこの問題で生じる事象の遷移のすべてである。したがって、遷移を追うためには、1,今何回目なのか 2,何円持っているのか 3,何連続なのか の3つの情報が必要になる。ここで例えば 1,2 を行と列に、3を値としてdpすることも可能だが、サイズの制約で実装できない。そこで 1,3 を行と列にすれば実装できるなと判断して解答する

このdpにおける基本の思考の流れ、特に遷移状態を追うために何の情報が必要なのか把握することができていない。dpっぽいなー　→ こういうのいっつも回数お金の2次元リスト作ればいけるからそうしよー、とやってるから解けなかった。



# 248C Dice sum  2回目   diff  748

解答遷移 AC

備考

➀　思考

数列を構成する数列を前から順番に見ていくと 、i+1番目の数字は 1～M でかつ その数で総和を更新しても Kより大きくならない条件を満たすものである。したがって 1,　今前から何番目か 2,総和はいくつか　の情報を保持すれば遷移状態を追えることになる。また、総和、つまりK は K <= NM < 2500 なのでdpするための2次元リストを作ることは可能である。



# ☆ 197C ORXOR  diff 809　　済

降参

備考

➀　思考

制約的にbit探索しそう。ただ、区間が2つとは限らないから違うのかな？　→ 最適化すると必ず2区間になるんだろうか？ 実験　→ １の偶奇で分類できそうだけど、複雑すぎてすべて追うのはきついし 2区間が最適かどうか結論づかない。 → 区間の数は最大でも N だからこれを全探索できないか？　→ でも 2つ以上箱作ってわけてくのきついしわかんねーな　降参

➁　解法

Aの要素間に仕切りを入れることで区間を表現すれば、仕切りを入れるかいれないかでbit全探索できる


③　反省

bit全探索は 2択の全探索　だから2区間が最適だと決めつけ、そうなることを示そうとし、時間も思考を浪費してしまった。いざ区間の数を探索しようとしたころには体力と思考力がなくなって十分な考察が行えず、解答もできなかった。


また仕切りで区間を表現することは便利なので反射的に思い付けるようにしたい


補足)

![image](https://user-images.githubusercontent.com/109026838/193567642-d6737281-325c-4271-824b-391519c9a19d.png)

この問題でも ^ と | を要素間に挿入し、 ^ ならば区間を区切り、 | ならば同じ区間とみなせばよい


# アルゴ式  dp 

# 1 最大和問題

解答遷移 AC

計 02:49

備考

➀　思考

bit全探索したいけど無理。 dpするにしても最大総和は目盛り的に無理だしな。。とりあえず実験。　→  普通に負の数無視すれば絵絵だけやん。実装　→　if 処理するのめんどいし、足して総和を更新しなかったら足さないをmaxで処理しよう　AC

* 結果的に意図せず dp になった

# 2 ナップサック問題

解答遷移 WA AC

計 15:34

備考

➀ 思考

dpしそうだし遷移状態を見る。 i+1番目の品物を選べるか否かは、i番目までの総和に依存する。また選んだ時の価値はi番目までの価値の総和とvi+1 になる。したがって、1,何番目か 2,それまでの重さの総和はいくつか、3,それまでの価値の総和はいくつか　の3つ情報で遷移状態を完全に把握出来る。価値の最大値を求めるので価値を要素にして更新していくのが良さそう。重さの最大値サイズのリストも作れるし。

* WA は選ばない処理を 選ぶ処理のif分の中に入れてしまったために生じた。選ばない方は一番先に処理してしまうのが良い。



# 3 部分和問題

解答遷移 AC

計 05:27

備考

➀　思考

bit全探索したいけど無理。実験 →　i+1 番目の処理は、i番目までの遷移に関係なく、選ぶ選ばないになってるな。1, 何番目か 2,それまでの総和　の2情報があれば遷移をすべて把握できるとわかる。求めるべきは総和Mになることがあるかどうかの存在確認なので、ある総和となる選び方があるかどうかFlagで管理するのが良さそう。Mもメモリを心配することのない小さな値である。



# 4 部分和数え上げ問題

解答遷移  AC

計 05:50

備考

全問と同じで、それに加えてその総和となる選び方の数も追いたいので、選び方の数を要素にすればよいと判断


# 5 最小個数部分和問題  

計 09:14

備考

baseは全問と同じ。あとは選んだ整数の数も把握したいので、選んだ数を要素で管理し、min処理すれば最小値がわかる。min理なので初期値はありえないでかい数を設定する


# 6  K 個以内部分和問題

備考

個数を管理し、K以下ならYes 


# 7 ☆  個数制限付き部分和問題

備考

➀　思考

遷移状態はこれまでと同じ。異なるのは同じ要素を重複して選べることだけだから、dp[i][j] が Trueなら dp[i+1][j+a[i]* k (<= b[i])] もTrueにする処理で良さそう。ただ計算量がとても気になる。例えば a=1 , b=10000 の場合は、True の要素 1つに対して 10000回消費するので、最高で O(NMb)になってTLEしてまうと思われる。→ 途中で一度でも Mになる選び方があればそこで打ち止めれば削減できそうだが、微妙。一応通すか　→ AC

➁　模範解答

dp[i][j] = i 番目までの整数の中から選んで総和を j とするときに含まれる A[i] の個数 とすることでこの問題を解答できる。jを前から探索して、 dp[i][j-a]<b なら まだ aを選ぶことができるので dp[i][j] = dp[i][j-a]+1 とできる。さらにdp[i+1][j]=0 になる。なぜなら i+1 番目までにおいて、a[i+1]を0個選んで総和 j にすることが確定しているからである。

* この問題ではそれぞれの個数にのみ制限があるので、このように解答できるが、もし個数の総数にも制限があったら例えば 個数の総数を管理するもう一つのdpを作成して同時に操作していくことで、一応解答できそう。つまり、Q6 とQ7を並行してやっていくイメージ



# 二分探索　勉強

単調性を持つ、または境界で真偽が2分する対象について、ある条件を満たす常に満たす範囲や境界の探索を行うアルゴリズム。

https://qiita.com/drken/items/97e37dd6143e33a64c8c#4-%E4%B8%80%E8%88%AC%E5%8C%96%E3%81%97%E3%81%9F%E4%BA%8C%E5%88%86%E6%8E%A2%E7%B4%A2%E3%81%AE%E9%81%A9%E7%94%A8%E4%BE%8B

探索範囲を (ng,ok] として mid = (ok+ng)/2　が 条件を満たす範囲に含まれるなら ok を更新し、そうでないなら ng を更新して、境界へ向かって条件を満たす範囲と、満たさない範囲を広げていく。最終的に境界を見つけることができれば、例えば条件を満たす最小値なら右端から広げてきた ok の値がこれを示し、条件を満たす最大値なら、左側から広げた ok の値がこれを示す。


https://www.forcia.com/blog/001434.html



# アルゴ式 二分探索

2-1 方程式を解く

解答遷移 AC

計 13:41


# 2-2 貯金 (1)

解答遷移 AC

計 12:27



# 2-3 最小の添え字

解答遷移 AC

計 05:40

備考

➀　思考

二分探索して A > B を満たすok 範囲 と満たさないng範囲を狭めていき、最終的に差が1になった瞬間全探索が終わり、ok範囲の最小値とはokそのものなのでそれを出力して完了

なお初期値は (ng,ok] のようにokは含めて、ngは含めないのがよいとみたので、ok=n-1,ng=-1とした。

![image](https://user-images.githubusercontent.com/109026838/193878360-993f6567-b1d2-4551-ac9f-9f195dee05bc.png)

****** 注意 *****

こんな雑に初期値を定めてはいけない

ok は条件を必ず満たす範囲であり、ngは条件を満たさない範囲である。たとえば A=[1] b=100　の場合 ok= 0 ( N-1 ) とはならない。なぜならA[0] = 1 > 100 とはならないからである。正しくは　ok=N ng=-1 とすべき。(ただしこの問題では A[-1]>b なので実は ok=N-1 としてもよい)



# 2-4 小さい数の個数

解答遷移  AC

計 09:36

備考

➀　解法

基本的には 2-3 と同じアルゴリズムであるが、 A < B の範囲を求めたいので、okを左側に設定する。また、Aのすべてが n より大きい、つまり条件を満たす範囲が存在しない場合を考慮して okの初期値は 配列外の -1 に設定する必要があることに注意。  


# 2-5 和が K 以上のペア

解答遷移 AC

計 07:17

備考

➀　思考

組合せの全探索は O(N^2)なので無理。Aiを固定すると、K-Ai 以上の要素の個数を求める問題となり、これはAを二分探索すれば解決するので、O(NlogN)で処理可能


# 2-6 重さは何番目？

解答遷移 AC

計 02:59

備考

copyして二分探索するだけ

# 2-7 貯金 (2)

解答遷移 AC

計 04:53

備考

➀　思考

n日後の貯金額は (n+1)n/2 でこれが初めてXを超えるようなnを求めたい。→ 二分探索で行けると判断。


# 2-8 ひもを切る

解答遷移 AC

計 12:37

備考

➀　思考

長さ t で分断するとすると、ひもL1からは L1//t 本、L2からは L2//t 本　作ることができる。この合計がK以上だった場合ok 範囲を広げる二分探索で tの最大値を求められると判断


# 2-9  九九の表 (1)

備考

➀　解法

・二分探索

ok=0,ng=N+1 として、数列 i,2i,3i,...において　Kがどの位置に存在するか二分探索すると　K以下の個数はok と求まる。

・ 数式変換

(i+1) * (j+1) <=K より i <= K//(j+1) -1  したがって min(i,N-1)+1　である行に含まれるK以下の個数が求まる。



# 2-10 九九の表 (2)










# 1004

# 224A Tiers diff 6

解答遷移 AC

計 01:23

備考

➀ 補足

name="tsuru" のとき name[-1000:]="tsuru" である。おそらく末尾と違って先頭は、0より前にアクセスしてもエラーにならず0にアクセスできるようだ。



# 225A  Distinct Strings  diff 12

解答遷移　AC

計 03:15

備考

➀ itertools.permuration

順列を生成。引数にはイテラブルとそこからいくつ取り出すかの情報が必要。返り値はその並び方。また、文字列も与えることができ、この問題はこの性質を利用することで簡単にとける


# 056C  Go Home  diff 731

解答遷移 AC

計 16:49

備考

➀　思考

dp。1, 時間　2,現在地 の2情報があれば遷移をすべて把握できる。しかし現在地をすべて管理するサイズのリストは作れない。 ほかに遷移に関わる情報を探す　　→  なし！！！　dp じゃないってこと？　実験　→ 時刻 t における最高到達点を Xt とすると、tまでに -Xt ～ Xt までのすべての地点に到達するルートがあることを確認。したがって、Xに最速で到達する時間とは、X<Xt を初めて満たす t となる。これは最高到達点の累積和を作成し、2分探索すればすぐに求まる。



# 245D  Polynomial division   diff 815

解答遷移 AC

計 42:03

備考

➀　思考

ややこしいから全部候補調べて、一致するの答える方針で行きたい。　→ B は最大 100項あり、係数は　-100 ～ 100 まで取りうるので 全探索する場合 約 O( 200^100 )かかるので絶対無理。実験してみる　→　はじめに B0が確定して、　次に ( C1 - B0 * A1 )  // A0 で B1 が求まる。　次は ( C2 - B0 * A2 - B1 * A1 ) // A0 にて B2 が確定する。　このように Bの係数は前から順に確定していき、その確定した値を利用して後の値も順に決まっていく。したがって Bを前から順に求めていけばよいと判断。 また、Bk を決定する際に B0 * Ak , B1 * Ak-1 ,....をいちいち計算するのは面倒なので、これらを Bi (0<= i <k) が確定した時点で随時計算してリストCC の　CCk　にでも累積しておくことで (Ck - CCk) //A0 で　O(1) 処理できると考え、これを実装してAC


➁　改善案 

そもそも Ck の 値 は Bk 計算時にしか使用しないので、CCなど作らなくても C の値を更新していっても全く問題ない。



# 　☆ 125D   Flipping Signs   diff 833

解答遷移 AC

計 1時間 over 絶対に本番で出てたら解けてない

備考

➀　思考

よくわからないので実験。　→ 前から順に決めていくと i+2 番目 に Ai+2 , -Ai+2 を選択することで Ai+2 が確定して i+1 番目までの総和も確定することがわかった。よって、1, 前から何番目か　2, i-2 番目までの総和   3,i+1 番目 が Ai+1 , -Ai+1 のどちらか　の3つの情報によってすべての遷移を把握できることがわかった。→ しかしAiにあわせたサイズのリストを作成することは不可能である。ここで例えば、 10(総和) - 4 - -8 の選び方と、 -10 - 4 - 8 の選び方は以降同じ遷移をし、必ず後者の総和が大きくなるので、この時点で前者を捨てることが可能なのですべての総和を記録する必要がないとわかる。よって行には番号、列にはAiの正負(つまりサイズ2) を割り振ったリストで要素(総和)を更新するdpを行えばよいと判断。

ここまでの考察にも時間がかったが、さらにここから index番号と、遷移の連動がうまくできず死ぬほど時間をかけてなんとかACできた


➁　考え方整理

まず i+2 番目に Ai+2 , -Ai+2 を選択した時点で i+1番目までの総和は確定するので、 -1ずらして考え、i+1番目の選択で i番目までの総和が決定すると考えてよい。するとdpにおける、i行目の処理は Ai+1 を選択し、i番目までの総和を確定する処理であることを理解しやすい。また、2番目,N番目を決定する際の処理が、3 ～ N-1 のmax処理と同様に行えないことに注意。


③ 別解

Aに 0 が含まれない場合、A の負の要素の数の偶奇は初期状態から変化しない。したがって、偶数個ならば絶対値の和が答えになる。奇数ならば必ず一つの要素は負になるが、任意の要素を負にできるため、絶対値が最も小さい要素を負にすればよい。

Aに 0 が含まれる場合、負の要素の偶奇を変更できるので ( 0 Ai の並びを 0 -Ai にすれば偶奇が変化する) 必ず絶対値の和が答えになる。



# 1005

# 218A    Weather Forecast  diff 7

解答遷移 AC

計 01:08

備考

なし

# 219 AtCoder Quiz 2  diff 6

解答遷移 AC

計 02:31

備考

なし

# 230C  X drawing  diff 566

解答遷移 AC

計 35:38

備考

➀ 思考

よくわからないので、実験　→ 1の操作で (1,1) ベクトル方向&逆方向のマスが、2の操作で(-1,1)ベクトル&逆ベクトル方向が塗られる。これは素直にkを探索することで求められる。あとは出力範囲の該当マスのみに対して操作したくて、全範囲だとA,Bが大きすぎる時ヤバいし無駄だなので。　→ A+kとしてありえる範囲を探索し、随時そのkを用いた B+k (B-K)が範囲内に存在するか確認してそうなら塗る操作が良さそう。　→ a+kを探索しているのでB+kの存在確認をするときに Aを引くことを忘れずに行ってAC

➁　別解

P<=i<=Q , R<=j<=S を探索した場合、操作１で塗られるマスでは、i=A+k j=B+k が成り立つことになる。ここからkを消去すると i-j = A-B となるので、A=B に一致するi,jのマスを塗ればよい。操作2の条件でも同様に i+j = A+B で考える。なお、minやmaxはつまり、1 ～ N 以下であることを保証するものなので、より狭い i,j を探索している状況では気にしなくてよい



#　☆ 160D  Line++  diff 879

解答遷移 WA AC

計 1:42:36

備考

➀　思考

普通の経路での最短距離と、XY連結経路での最短経路を比較すれば最小距離を得られると考えた。制約的にも素直に始点を全探索して毎回bfsしても間に合うので。　→  しかし、iとi+1がつながっているという表現につられたのか、頂点は前から順に探索するだけでよく、戻ることはないと考え一度始点になった頂点を探索しないbfs をしたり、戻らないので、X-1とXはつながっていない方がいいいいと考えて分断したりと、随所で誤りを起こし、サンプルと合わず苦戦した。　2-3-4...-7 (X=3,Y=7) などでは4-7間の最短距離は 4→3→7　と辿る場合で頂点３に戻る必要があるので戻ることもあるし、分断もゆるされない。

➁　別解

1-2-..-3(X)..-7(Y)...-10 の経路において、1から10へ行くには 1, 素直に1-2-...10と辿る 2, 1-X-Y-10 と辿る2つの方法がとれる。前者の経路は距離 10-1=9 であり、後者の経路は |10-Y| + |1-X| である。したがって、始点と終点を全探索しこれらを比較して最短距離を管理できれば bfs することなくこの問題は解答できる。




# ☆ 154D Dice in Line  diff 485

諦め

備考

➀　思考

よくわからないので、実験　→  めちゃめちゃ煩雑だが期待値の和は求められる。ただ区間の期待値はわからない。一応 累積和の様に x番目の期待値から y-1 番目の期待値 を引くことで、y-x区間の期待値に一致しそうな気がしたので、保証はないがそれで解答することにした。　→ TLE  → 自分の案だと期待値の合計の分子まで記憶する必要があり、大きすぎる数字を生成する可能性があるのでTLEしたのだろう。 →　改善案として、区間がずれるたびにすべての期待値を引いていく処理を考えたが、これではループが増えてO(NK)になって結局TLEしてしまう。ここで降参 


➁　解法

![image](https://user-images.githubusercontent.com/109026838/194077941-2ef99a73-93c7-4bea-a14b-d188e864c5db.png)

https://manabitimes.jp/math/698

独立な確率の和の期待値は、期待値の和に一致する性質を利用。尺取り法で連続k区間の和を求めて最大値を更新して完了できる　




# 1006

# 216A Signed Difficulty  diff 17

解答遷移 AC

計 03:36

備考

なし

# 217A Lexicographic Order  diff 21

解答遷移 AC

計 02:02

備考

文字列どうしは比較できる


# 232D Weak Takahashi  diff 539

解答遷移 WA AC

計 49:44

備考

➀　思考

dfsして、seenの合計で一瞬だな。→ 戻ることができないんのでこれではだめ。→ だったらbfsで最短経路を記憶して、その最大値求めた良さそう。　→ WA →本当になぜ WA なのか不明なのでサンプル作って確認することに　→ なんと処理自体は全く正しいが、max(max(dist))で正しく最大距離が出力されていないだけだった。ので仕方なく、全探索してans更新することに


➁ 多次元リスト max 

numpy のようにはならない。

https://qiita.com/recuraki/items/d4a2e5d5accdbb90321e



# 111C  /\/\/\/  diff 826

解答遷移 AC

計 58:01

備考

➀　思考

偶数番目と奇数番目の出現個数を別々で管理すれば簡単に解答できそうだと考えた。問題は最頻値の要素が一致した場合であり、しばらく考えて、これはどちらかの2番目の最頻値のうち大きい方の要素をその代表値として、もう一方は1番目の最頻値の要素を代表にすればよいとわかった　→ ここですべての要素が同じ場合の処理を施していなかったことにサンプルテストで気づき、修正してAC

正直サンプルが不親切だったら、それまでにとても時間がかかったこともあってAcできていなかったかもしれない。


➁　改善

どちらかの要素がすべて同じ場合の条件分岐が面倒なので、[0,0]を追加すればよい



# 212D  Querying Multiset   diff 775

解答遷移 WA AC

計 11:49 + 05:00

備考

➀ 思考

優先度付きキュー使えば解決しそう。query2だけめんどいけど、累積する値を記憶しといて、出力時に足せば良さそう　→ WA → よく考えたら 12 , 13 , 22 , 13  の順に操作したら中身は 3 4 5 になるが、自分の処理では最後に累積した後に追加したボールにまで累積値を追加してしまう。これを回避するために追加するたびに、その時点の累積値を引いた値で追加しておけば順序も正しいし、最後に現時点での累積値を追加できるのでこれで良いと判断。AC




# 141D Powerful Discount Tickets   diff 823

解答遷移 AC

計 40:36

備考

➀　思考

二分探索しそうー(というか使いたいだけか) 。ただ商品ごとに割引券使う枚数変わるのでしんどそう。　→ 素直にdpするか。 1, 前から何番目か、 2, 割引券残数 3, i番目までの総和 がわかれば遷移状態を完全に把握できる。行列サイズは (前から何番目、残数)にするのが良さそう。M<10^5 で目盛り的にもよい。 → ただ i番目に残数m の場合 dp[i+1][m],dp[i+1][m+1],...dp[i+1][M]まで更新する必要があり、これではO(NM^2)で処理不可能。　→ 貪欲法か？　→ 一番お得なのは X -　X//2 が最大のもの、すなわち 最大のXに割引券を使用するのが最適である。 したがって、優先度付きキューで常にO(1)で最大値X を取得できるようにして、X//2 を追加していけば解答できると判断。AC

➁ 注意点

最大値を取得するために、負値を格納する必要があるが、// はガウス、つまり負の範囲では小数点切上げになってしまうので、int()にするか、正の数に直して演算しなければいけない。intは小数絡むし、正数変換する方が良いか。



# 061C Big Array  diff 808

解答遷移 AC

計 09:46

備考

➀　思考

SortedSet か　優先度付きキューで管理すれば良さそうだなー →  個数も必要だから優先度付きキューにしよう。あと既に存在する要素は、個数を追加したいな　→ それならその要素にアクセスしたいが何番目に存在するかわからないから不便だな。　→　普通に 1～ 10^5 までの個数を管理すればいいだけやん！　→ 前からremを更新していって初めて0以下になる場所を出力して完了



# ☆ 193D Poker  diff 866

降参

備考

➀　思考

普通に#としてありえる候補を全探索すれば解けそう → サンプル１の場合 10/25 になって 4/9にならない。何がおかしいのか30分考えてもわからず降参

➁　解法

例えば、5と5を配る確率は、2/25 * 1/24 になる。5と9では (2/25)^2 になるので25通りの選び方は同様に確からしいわけではないのだ。したがって、条件を満たす選び方が10通りあるので、10/25 にはならないというわけである。

これまでは選んで戻したりして、全体の確立が変らず常に同様に確からしい確率の範囲で解答できる問題にしか出会っていなかったが、以降注意したい。




# 189D Logical Expression diff 769

解答遷移 AC

計 30:19

備考

➀　思考

bit全探索したいけど無理。dpでいけそう。1, 前から何番目か 2,xi+1  3,yi の情報ですべての遷移を把握可能。 → x,y の2種類が存在すると2次元では管理しにくいので 3次元に拡張し、 axis=0 で　xi+1の種類で分類し、axis=1 に前から何番目か axis=2 に yi の個数で管理することにして最終的に dp[0][-1][0]+dp[1][-1][0] を出力してAC。


➁　別解

xi+1 = True かつ Si = OR の場合、yiの値に関わらず yi+1 = True になる。これを満たすのは 2^i 個。Xi+1 = False の場合は yi=True の必要があるので Si = OR の場合、yi+1となる並び方の総数は合計で 2^i + (yi=True の総数) となる。 Si = AND の場合は xi+1 かつ yi = True でなくてはいけないので、総数は (yi=True の総数となる)。

つまり S[i] = OR の場合 yi=True の個数を 2^(i+1)個増やしていくだけでこの問題を解答できる。ANDの場合は増えないので何も処理する必要がない



# 1007

# 214A New Generation ABC diff 4

解答遷移 AC

計 01:25

備考

なし


# 215A  Your First Judge   diff 7 

解答遷移 AC

計 01:17

備考

なし



# 250C Adjacent Swaps diff 517

解答遷移 AC

計 55:13

備考

➀　思考

ふつうに入れ替えれば良さそう。→ 操作後の任意のボールの位置を把握できていないといけないことに気が付く。これはボールの位置を管理するリストを作成し、入替で1増やしたり減らしたりすればよい。 → サンプルで確認。合わない　→ 入替先のボールは位置リスト内の前後に存在するわけではないことに気が付く。入替先のボール何なのかはindex()などで得ないといけないが、これではO(N^2)かかる。→ そこで ある位置に存在するボールが何かを管理するリストも追加で作成すればよいことに気が付く。これで完了


# 169B Multiplication2 diff 352

解答遷移 AC

計 07:53

備考

➀ 巨大数計算量

N ( 10進数表記桁数 n10 ,2進数表記桁数 n2) 
 

・四則演算

掛け算なら O( n10 log n10 )

![image](https://user-images.githubusercontent.com/109026838/194547231-ce83926b-abca-45b4-b513-3eedd1070325.png)

https://qiita.com/square1001/items/1aa12e04934b6e749962#2-2-%E5%A4%A7%E3%81%8D%E3%81%AA%E6%95%B0%E3%81%AE%E8%B6%B3%E3%81%97%E7%AE%97

・累乗

O(log2 n2)

![image](https://user-images.githubusercontent.com/109026838/194549272-e3433336-fceb-43ec-a821-33b5daeeae92.png)


したがって例えば 2^(10^7) を素直に計算するのは難しい(238A 07) が、この問題の様に 10^18 * 10^18 程度なら18 log 18 なので余裕で処理可能


➁　解法

➀で述べたように 10^18 までの計算程度なら余裕で処理可能なので、普通に掛け算を行って、10^18を超えれば -1 出力する処理で解答可能。ただし、10^18を超えたあとに0が登場する場合が例外になってしまうので、昇順にするなどの工夫が必要



# 139D ModSum  diff 397

解答遷移 AC

計 11:14

備考

➀　思考

制約が強すぎて、探索すらできない。とりあえず実験しよう。 → 1,2,3,4 ... N それぞれについて最後のN以外は -1 した値が余りになる可能性があり、かつ 2,3,4,5...N-1,1 とすればすべて最大の余りにできることがわかった。また、NになにXを割り当てても、最大でもあまりはX-1 にしかならず、これは X-1 にXを割り当てた場合と変わらないので、Nに1以外を割り振ってより得をすることもない(現状維持が最大)。 したがって、 2,3,4,5...N-1,1と割り振って余りが 1,2,3,...N-1,1 となる場合が最大値となる。


# 1008

# 212A Alloy diff 5

解答遷移 AC

計 03:44

備考

なし


# 213A Bitwise Exclusive Or diff 33

解答遷移 AC

計 01:58

備考

➀　XOR 演算

A XOR B = C  ⇔  A XOR C = B ⇔ B XOR C = A 


# 255C ±1 Operation 1   diff 574

解答遷移 AC

計 29:55

備考

➀　思考

As = A , Ae = A+D(N-1) (数列の末端)とする。 

等差数列をすべて管理できれば二分探索で近傍にアクセスして差をとればいいのだが、Nがでかすぎて無理。　→ 
等差数列の値は必ず Dでわった余りがAであることに注目して X%D との差をとればよいことを思いついた。あとは Xが数列の範囲に存在しない場合だけ別で処理すれば完了!! → サンプル3 があわない。ここでようやく各値が負の範囲で動けることに気づく。→ D<0 の場合だけ割り算が成立しないし面倒すぎるので、これをうまく処理できないか考察　→ 数列をひっくり返せば、つまりAs = Ae , Ae = As とすれば D=-D としてDを正の範囲で処理できることに気づく。これで完了

➁ MOD 演算の基本

A>X や A<0 を考慮して (A%D-X%D)%D としてが、最終的にmodをとるなら、個別でとる必要はない。


③ 二分探索

リストを作ることはできなくても二分探索はできる。例えば、1 3 5 7 9 11 の数列に対して  ok=0 ng=6 (項数 6) として 1+mid* 2 (公差) <= K とすれば何項目まで K以下なのか求めることができる。


# 255D ±1 Operation 2  diff 788

解答遷移　AC

計 35:19

備考

➀ 思考

各クエリに対して、各要素に何回操作が必要か求めるのは無理。→ 足りない分をベクトル演算できそうだと考えた。例えば 6 11 2 5 5 に対して、 X=20 なら 14 9 18 15 15 回ずつ必要だが、各要素どうしのベクトル列 0 5 -4 -1 -1 のそれぞれについて 20-6 =14 との差が 14 9 18 15 15 に一致することを利用できないかということである。確かに X<=2 , 11<=X の範囲であればベクトルの符号が全要素同じなので、このような演算で回数に一致させられるが、 2<X<11 の範囲ではこの演算では回数に一致させられない。　→ 2<X<11 に注目。数列をソートすると二部探索でき、その境界前後でXに一致させるのに + する必要があるのか、 - する必要があるのか変化することがわかった。したがって、境界前後の総和に対してそれぞれの個数分 X をかけた値との差が求める回数になると気づいた。区間和は累積和でO(1)処理して完了



# ☆ 263D  Left Right Operation   diff 1016

降参

備考

➀　思考

累積和をとって、どこまでで変換すればいいか探索する方針を考えたが、うまくいかず降参した


➁　解法

Aを前から探索して、i番目までの総和の最小値を求めることにする。例えば 1,100,1,100...　,L=10 の場合、1番目までの総和は 1 or 10 なので  1。 2番目までの総和 は 1番目までの総和 + 100 or 2L で 20 と求まっていく。末端からの操作も同様に考え、N番目から k 番目までの総和の最小値を求めていき、最終的に 先頭から l 番目までの総和の最小値と 末端から l+1番目までの総和の最小値において、lを1～Nまで動かしたときの最小値が答えになる。

③ dp

Aを前から探索して、-1番目が RならR、Ai-1ならAi またはR、LならL,Ai,R と求まるので、i, 前から何番目か 2,i番目までの総和 3,i番目が L,R,Aiのいづれか　の情報で遷移を完全に把握できる。これで最小値を求める

④　反省

1,100,1,200,1.... の場合に 100 と 200 のところまでは進めたいから、、、と初めから条件を設定して、それを満たせるように処理を考えるのはナンセンス。

困ったらとりあえず前から探索する。 




# 272

# D Root M Leaper

備考

➀　平方数列挙

x^2 + y^2 = M を満たす非負整数(x,y)の組みを求める。

0<= x <= M の範囲において、ok=0 ng >M と設定して求めた mid の2乗 が M-m 以下であれば ok を、そうでんばければngを更新していく。これによって ok^2 <= M-m になるが ok^2 -= M-m であれば x^2 + y^2 = Mを満たす(x,y) = (m,ok) が成立する。 

また、例えば 1^2 + 8^2 = 65 であるが、 4^2 + 7^2 = 65でもあるので、一組見つかっても終了してはいけない。m^2>M になって初めてbreak可能


https://yatt.hatenablog.jp/entry/20130128/1359370204


➁ WA

(1,1)から移動できない場合の処理がうまくできていなかったことが原因。しかしこれだけで WAが10個モデルとは思えずメインの処理に理由があると思い込んで時間を迎えてしまった。一つでもサンプルを与えていれば見つかっただけに悔しい。


* 1028 追記

272D

メモ dx,dyは√M以下なので全探索可能。さらにNを超えるとマス内部を移動できないことに気づけば探索範囲は√Nになる



# 1009

# 210A Cabbages  diff 19

解答遷移 WA AC

計 05:02 + 05:00

備考

1, A>N の場合を忘れない

2, WA食らう方が痛いので、かっこつけてmin,maxで条件分岐なくすより、素直に全網羅したほうが脳死で間違えずかける気がする



# 211A Blood Pressure   diff 6

解答遷移 Ac

計 01:11

備考

なし



# 256D Union of Interval  diff 546

解答遷移 WA AC

計 38:32 + 05:00

備考

➀　思考

最終的な連続区間の始点と終点がわかれば解答できる。これは、L,R を区別するために X[L]は+1,L[R]は-1 して、初めて0を超えた場所を始点、その後カウンターが初めて0になった場所を終点とすればよいことに気づいたが、WA → なにが間違っているかわからず、もたもたサンプルを作成した後、カウンターをX[i]の値で増減していないことに気づいて修正 AC

➁ 修正 と imos法  * 類題 183D

カウンターをわざわざ作成しなくとも、累積和をとれば簡単に始点と終点がわかる。


③ サンプル作成

まず f.write()で書き込めるのは文字列だけ。

書き込み時、print(f.write(文字列))とすると、適当な数字がターミナルに出力されてしまう。printしなくとも書き込みは成立する。全く不要





# 221D Online games  diff 832  2回目

解答遷移 AC

計 30:43

備考

➀ 思考

ログイン時に +1 して、ログアウト時に -1 して時間を前から探索すれば解答できる(imos法)。しかし、これを管理するリストを作るにはメモリが足りないし、そもそも探索することもできない。　→  現在何人ログインしているかを持っておきながら、ログイン、ログアウト時のみを探索すればO(2N)で人数を把握できそうだと判断。ログイン時とログアウト時が被ってもその間の時間は0なので、人数カウンターをその分インクリメントしても問題ないことに注目。ログイン、ログアウトをともにソートして、前から探索　、探索のたびに前回の探索時の時間から現在時刻を引いたものが現在人数から変化せずログインされ続けた時間になる。その後、現在時刻を更新し、ログインなら人数を増やし、ログアウトなら人数を減らす処理で完了


➁　別解

collection.Counterでログイン、ログアウト時を管理する。これによって 2Nのリストから、2N以下のカウンターにメモリが削減されるし(重複時)、ログインか、ログアウトかをカウンターの要素として記憶できるので、処理も簡単になる。


# 158D String Formation  diff 610   類題 199C 

解答遷移 AC

計 13:36

備考

➀ 思考

ボトルネックは文字の反転であるが、ほかの操作をいじることで擬似的な反転を実現させたいな　→ T=1 になるたびに反転flagを入れ替えて、T=2の場合に反転フラグが立っていたら、文字列が反転していると考えて挿入位置を入れかえればよい。また、反転フラグの入れ替えはXOR演算でflag^=1とすれば　1なら0に、0なら1に場合分けせずに統一できる。さらに、挿入位置の入れ替えも、(quuery[1]-1) ^ flag とすれば、flagが立っていない場合にそのまま query[1]-1の値が得られ、falgが立っていれば0なら1が、1なら0が得られる。


# 199C IPFL  2回目 diff 436

解答遷移 AC

計 12:45

備考

➀　思考

疑似的な入替で高速化したい。→ 入替flagで状態を管理して、入れ替えている状態は index番号が +N %2N であることを利用し、AとBを入れかえればよいな


# 258C Rotation  diff 419

解答遷移 AC

計 05:49

備考

➀　思考

取り出すindex番号を、現在のindex番号に合わせられたら O(1)で処理できるな。→ t=1 のxを累積すると、(x-1-tmp)%N が取り出す位置になることに気づいて完了



# 168A ∴ (Therefore) diff 12

コード作成なし

備考

➀ 1の位の出力

1, %10 

2, 文字列 S で受け取り、S[-1]



➁ 分類方法

1, 数字 → リスト内検索 ex) s in [0,1,6,8]

2, 文字列 → 文字列内検索 ex) s in "0168"  * 一桁でない場合では注意が必要




# 1010 

# 158B Count Balls  diff 123

解答遷移 AC

計 03:08

備考

なし



# 188D Sunuke Prime  diff 933

解答遷移 AC

計 53:53 + α (スタート押し忘れ)

備考

➀ 思考

imos法使いたいけど、制約的に無理だから、221D方針で行こうと考えた　→　しかし1日しかサービスを利用しない場合など ex)  a a c   のような場合で うまく処理できないことに気づいたので、開始日を 2a 終了日を 2b+1 と開始と終了を同日でも区別できるように調整した。また、切り上げ演算すればこの調整があっても正確に継続日数を出力出来ると判断した。　→　サンプル 2,3が微妙にあわない。　適当なサンプルでデバック　→ 例えば 1 2 6 , 1 100 10,  3 4 7 では、1 , 4 , 5 , 8, 200 の時間になるが、 4 と5 の間は日の間であるので、この区間では料金は発生しないはずである。しかし自分の処理では 100円のサービスを 1日することになってしまう。これを回避するために、探索時に前回時点が終了時だったら、それを+1することで全部丸く収まってACできた。

➁　改善

方針自体は完全に同じだが、開始日を -1 すれば時間軸を調整せずに済む。これはi日目の始まりを i-1 ,終わりを i　とすることと同義であり、これによって同日であっても終了時から開始時を引くことで1日を出力できるようになるし、自分の実装で問題になった日の間もなくなる。



# 235D Multiply and Rotate  diff 862

解答遷移 AC

計 38:43

備考

➀　思考

1, 何番目か 2,i番目の末尾の数　ですべての遷移を把握で気はするが、番号の定義がわからないし、そもそも何回目まで見れば良いのかわからずdpではなさそうだと判断。→ 入力された数字を操作した後に出力される数字の桁数は入力数字の桁数以上であること(小さくはならないこと)、N<10^6 であることから、素直にbfsで探索できそうだと判断。

➁ 注意点

文字列が絡む条件分岐には最新の注意が必要。Xが10で割り切れないとは

1, X%10!=0

2,str(X)[-1]!= "0"  ( !=0 ではない)


# 130D Enough Array  diff 865

解答遷移 AC

計 12:06

備考

➀　思考

負の値がなく単調増加する連続区間だから尺取り法使いそうだな。でもK "以上" か.. → 一度でもK以上になったらそれ以降の要素分答えに追加する処理で問題なく完了できそうだとわかり完了

# 066B ss    diff   384

解答遷移 AC

計 06:17

備考

➀ 思考

普通に毎回末端2文字削除して条件を満たすかどうか判定すれば良さそう。2文字の場合は2文字減らさずに答えが1になるので、減らし続けて2文字になった場合にこの処理を行えるような実装をして完了




# 1012 

# 208A Roalling Dice   diff 28

解答遷移 WA AC

計 06:30 + 05:00

備考

dp的に考えればわかるが、A回ふった場合 A　～ 6A の範囲の任意の整数をとりうる。


# 209A  Counting  diff 5

解答遷移 AC

計 01:22

備考

なし


# 161D  Lunlun Number  diff 991

解答遷移 AC

計 37:58

備考

➀ 思考

実験によってi+1桁であって条件を満たす数のうち先頭がxのものは x + (i桁であって先頭が x-1,x,x+1 のいづれかである条件を満たす数) として表せることがわかったので、1, 何桁目か 2, 先頭の数字 3, 個数 この3つの情報で遷移を完全に把握できると判断した。　→ 1を行に、2を列にすればよさそうだが、問題は何桁目まで調べればいいかわからないことである。 K<= 10^5であり、実験によって 10^4桁目まで行く前に K 番目の数は見つかると判断したので(証明などはない)、K番目まで条件を満たす数を全探索する方針に。→ while ループで随時dpにappendしていき、最新の行を取り出して操作していくことにした。また、2桁目以降0始まりで条件を満たす個数をカウントこそしないが管理する必要があったので、0～10までの長さ11のリストを用意することにした。これによって 0 始まりの場合だけ別で処理すれば、頭が9であっても前の行の -1,+0,+1 のインデックスにアクセスして個数を累積する処理でまとめられるようにした。ただし10は更新しない → ここまでで個数を完全に管理できるようになったが、K番目の具体的な数を求める必要があるので、
個数に加えて、条件を満たす数そのものも記憶する処理を追加した。具体的には、dpの要素として[ 個数 ,[ 条件を満たす数の文字列]] とした。　ただし9始まりの場合 8,9,10の個数を累積することは許されるが、文字列の更新時は　10に格納された意味のない文字列を反映させたくないので、10の初期値を[0,""]として,
文字列を更新するのは空でないときという処理を追加することで完了できた。


➁　別解

1,9を前から順に探索し、1を取り出して10,11,12 と作り、2を取り出して21,22,23と作り、これをK個に到達するまで繰り返すことで解答できる。正整数は取り出した数をXとすると、10X+X%10 +(-1,+0,+1) となる。X%10=0 or 9の場合に注意


# 1013

# 206A Maxi_Buying   diff 5

解答遷移 AC

計 02:57

備考

なし

# 207A Repression  diff 5

解答遷移 AC

計 01:20

備考

なし


# 145D Knight   diff 1099

解答遷移 WA 降参

計 1時間 over

備考

➀ 思考

1, 何回目か 2, 到達個数 ですべての遷移を把握できるのでdpしようと考えた。2次元空間に対応すべく axis=0で回数を管理しようと考えたが、そうなるとO((10^6)^3) になるのでできない。　→　次にbfsで(X,Y)までの経路を知らべ用途考えたが、こちらもTLEすると判断した。最終的に bfs + dp の複合合わせ技で突破しようとしたが、やはり厳しい　→ ここで冷静に状況を整理するため前から実験。すると (1,2) ,(2,1) ベクトルの個数は(X,Y)で一位に定まることを発見した。それぞれを a回、b回とすると答えは a+b C a になる。combではTLEになりそうだったので逆元の考えを思い出して解答。サンプル２からマスの合計は3の倍数である必要があるのでこれを満たさないものをあらかじめ取り除く処理で完了。。。かと思ったが2WA 。結局原因がわからず降参

➁　解法

解法は完璧 (300,3)など 3の倍数かついけないマスがある。a,bの探索時、すなおにX,Yのどちらにもあてはまる条件処理を施せば回避できた。

③ 逆元計算

nCm は 1～mまで探索して m*(n-i+1)%MOD を計算すればよい。


# 264D  "redocta".swap(i,i+1)  diff 414　 (1028 執筆)

解答遷移 AC

計 37:51

備考

➀　思考

素直に入替を実装しても atcoder が短いのでできると判断 ? ( 既に遠い記憶だしコードも可読性なさすぎて解読したくない)

➁ 1028　法

入替を実装しなくとも、a が atcoder に対応する位置にたどり着くまでに何回操作を行うべきかは 初期位置 - 0 でわかる。この操作で a より前にいた文字は一つ後ろにずれるので初期位置を+1することで t 以降の文字でも同じ処理で何回操作を行うべきかわかる。+1 操作は 1+2+...+6 = 15 回だけなので十分高速



# 1015

# 174A   Air Conditioner   diff 7

解答遷移 AC

計 01:02

備考

なし



# 174B  Distance  diff 43

解答遷移 AC

計 02:51

備考

距離が D　なので D^2  を比較する。



# ☆ 152D Handstand2  diff 1045

降参 → AC

計 1時間over(本番では絶対間に合わない)

備考

➀　思考

N以下の正整数をすべて探索し、その数の末尾から始まり先頭で終わる数を桁数ごとに求めることができると判断。最高でも6桁なので　O(6N)　となり十分高速。　

しかし場合分けが非常に煩雑で、死ぬほど時間がかかったうえに、一度諦めた後再度考えてAcできた。

➁　模範思考

この問題で重要になるのは、先頭と末尾である。したがって、A=1,11,101,111,...1001,1011,.... がすべて同じものとして管理できれば数え上げが簡単になりそう。→　直接 (先頭,末尾)の状態で管理すればよい。その後N以下の整数を全探索して、それらについて(末尾,先頭)の個数が条件を満たすBの個数に一致することを利用して数え上げる。



# 172D

解答遷移 AC

計 46:21




# 116C Grand Garden  diff 542   (1026 執筆)

解答遷移 AC

計 17:38

備考

➀ 思考

水やりできる連続区間を調べたい。→ 高さを前から順に探索しhをデクリメントしながら 0 でない区間の数を数える処理を行う。O(N* maxH) より十分高速

* 1026 

デクリメントしなくても水やりできる数は maxH なのだから回数が増えるたびに高さを比較する対象の方をインクリメントした。


➁　別解

単調に高さが減少する連続区間 X において、水やりが必要な回数は h[X[0]] 回である。なぜなら X[0] が h[X[0]]に到達するまでに、そのついでとして X のすべての要素が目標値まで到達することになるからである。したがって、前から順に探索し、hi > hi+1 になるまでは その区間の先頭の高さ分だけ回数を増価させ、hi > hi+1
になったら次の区間の始まりになるので、回数にさらに hi だけ追加する処理を続けることで解答できる

この処理は maxH に依存せず O(N) となるためより優れている

https://yamakasa.net/atcoder-abc-116-c/




# 133C Remainder Minimization 2019  diff 592

解答遷移 WA AC

計 13:37

備考

➀　思考

[L,R] に2019が含まれていれば簡単。これはL//2019 と R//2019 が一致しなければ必ず2019をまたぐと考えて判定することが可能。含まれる場合は。L,Rを2019の余りに変換し、2019=3* 673 から 3と673が...と考えようとしたがとてもめんどくさそうだと感じた。ここで2019までならi,jを二重ループで探索できることに気づいてこれを実行しAC

* なお 1WAは for j in range(L+1,R+1)としてしまったことが原因。正しくは i+1 である


# 258D Trophy   diff  687  (1028 執筆)

解答遷移 AC

計 13:00

備考

➀　思考

制約的にdpは無理だな　→ 貪欲に解くとして、B の 最小値を繰り返すのが最適になることがわかる。→ どの面までクリアするか前から順に探索し、i面までで X回 クリアする場合 i面までの初回クリア時間 + それまでの最小の B × (X-i) 時間でかかかるので、この最小値を答えにすればよいと判断

➁ 類題?

1021  085D Katana Thrower   



# 145C Average Length  diff 340  ( 1028 執筆)

解答遷移 AC

計 09:59

備考

➀　思考

O(8!1)は十分高速なので、 permurationで全探索して、最後に総数から平均値を出力すればよいと判断



# 269C Submask   diff 384   本番後 初　　( 1028執筆 )

解答遷移 AC

計 17:11

備考

➀ 思考

N(2) を前から順に探索し、1の場所では 0 or 1 、 0 の場所では 0 であるものが x としての条件を満たす。また 1 の場所は 15 個以下であることがわかっているため、 1　の場所で 0 になるか 1 になるか bit 全探索すればよいと判断

➁ 補足

もしも N 以下の非負整数が全探索できるなら N OR n が N に一致する　すべての n を出力する単純な bit演算処理で解答できた。


# 1016

# ☆ 219D Strange Lunchbox  diff  1085  (1024執筆)

降参

備考

➀　思考

たこやきの遷移とたい焼きの遷移を同時に把握する必要があるが、例えば axis=0 でこれらを分離すると遷移が分離するのでこの方法は不可。→ 300300 のような値でたい焼きの数とたこ焼きの数を同時に管理することを考えたがこの場合 o(N* 300301) はギリギリTLEしてしまう → 打ち手がなくなり降参

➁　解法

i番目のたこ焼きとたい焼きの数を同時に管理したいならば、Axis=0 で番号を管理すればよい。 つまりdpをaxis=0方向に進めることで遷移を追えるようになる。なお、X,Yを超える場合は末端に集約しておくことで、最後にdp[-1][-1][-1]を見て判定することができるうようになる。


# JSC2021C  Max GCD2   diff 343  (1024 執筆)

解答遷移 TLE TLE WA AC

備考

➀　思考

素直に gcd 求めてTLE　→ 公約数の候補は 1 ～ B なのでこれを対象にエラストテネスの篩方式で O(NlogN) で全探索し、各候補について A　～ B の範囲で候補の倍数が２つあれば条件を満たすとして最大値を求める処理を考えた

③　別解

累積和の要領で A-1 // gcd　と B//gcd　を比較し後者が2以上大きければ A ～ Bの範囲でgcdの倍数が2つ以上あるとみなせることに注目



# 112D Partition  diff 1025  (1024執筆)

解答遷移 AC

計 12:50

備考

➀　思考

公約数は M の約数である必要があるのでMの約数を列挙し、約数gについいて、M//g がN以上であれば a1～anが存在するのでgは条件を満たす。逆にM//g<N の場合gは条件を満たさない。したがって条件を満たす約数のうち最大のものを求めればよいと考えた。M<10^9 なので 約数列挙は O(10^3) で約数も 2* 10^3個以上は存在しないので十分高速に探索できると判断　→ AC




# 157B  Bingo  diff 107  (1024　執筆)

解答遷移 AC

計 17:56

備考

➀　思考

行のビンゴ以外とても面倒だが、各列、各ななめのそれぞれを構成するマスを探索した際に B に含まれていれば+1する処理を行い、最後にいづれかが3になっていればビンゴ成立と判定する処理を考えた

➁ 別解

探索を行わず、各行、列、ななめを構成する3つのマスの状態を直接調べてビンゴかどうか判定してもよい。また、ななめは偶奇で処理すると少し簡単になる



# 159B　　String Palindrome　diff 92  (1024 執筆)

解答遷移 AC

計 05:13

備考

➀　思考

全体が回文かつ、前半部と後半部はともに回文であるから前半部と後半部は同じ回文である必要がある。これを判定すればよいと考えた




# 140 Face Produces Unhappiness   diff 1074 (1024執筆)

解答遷移 AC

計 47:57

備考

➀　思考

よくわからないので実験　→ 1,連続区間を伸ばしたい 2,操作によって端を連続にすることはできるが、それ以外の連続性は変化しない(ここまで明確に意識できたわけではなかったが)  例えば LR LRRL RL  列に対して LR RLLR RL とすれば操作対象区間の端点の向きが前後で一致し連続になる。 →　このことから、Lを操作対象に考え前から順にLからRに変化する場所を K回見るまで探索しながらそれまでの長さを測定すればよいと考えた。 

Lを操作する場合にLが末尾の場合に困るので L から R に変化する場所の回数を測定していること、L始まりの場合にそこでは操作しないようにすること、Rが連続している場所の処理など、様々な工夫によってギリギリのバランスでACすることができた

➁ 模範解答

自分の思考に加えて、幸福度が捜査対象区間の端点部で +2 されるだけであること、もともと連続な部分の幸福度は操作によって変化しないことに注目→ 列の連続部の数と変化部の個数を調べ、変化部分の個数が 2K以下であれば向きを完全に統一できるので N-1 、そうでなければ K回の操作で 2K だけ幸福度が増えるので、答えは 連続部の長さ + 2K になる

③ 参考

https://zenn.dev/knk_kei/articles/memo-abc-140-d



# HHKB 2020  Neq Min   diff  352  (1024 執筆)

解答遷移 RE AC 

計 08:23 + 05:00

備考

➀　思考

現在出現していない数を毎回探索するのは非効率 → SortSetで管理し、出現した数をdiscardしていく。都度一番小さな値を出力すればよいと判断　→ RE →　サイズを適切に修正してAC

➁ 別解

出力する値が単調に増加していくことに注目 → 出力の値から次に条件を満たす値が見つかるまで探索を行う、尺取り法の要領ですべてのクエリに解答することができる


# 133D  Rain Flows into Dams  diff 938  (1026執筆)

解答遷移 AC

計 43:57

備考

➀ 思考

よくわからないので実験　→ まず山1に 0L 降ったすると山2 から A1-0 L だけ ダム1　に送る必要があるので、山2 には 2A1 L 降ったことになる。するとダム2に　A2 - A1 L 送る必要があるので山2 には 2(A2-A1) L 振ったことになる。ダムには山からしか雨が送られないので、A の和 と 山に降った雨の総量は一致する。よって sum(A) = 2A2　となるはずである。一致しない場合は初めの仮定が間違っていることになる。→ ここで 山1 の雨量を +2 すると、山 3,5,7...の雨量も +2 され、山 2,4,6...の雨量は -2 される。総量としては +2 となるので、不一致度分だけ 奇数山の雨量を増やし、偶数山の雨量を減らせば答えが求まると考えた。


➁ 別解

各山に2M0,2M1,....2Mn-1 振ったとすると、M0+M1=A0,M1+M2=A1,....Mn-1+M0=An-1 が成り立つ。ここから 2M0=A0-A1+A2....　が成り立ち 山0 の雨量が求まる。→ Mi+1 = Ai - Mi から残りも求めることができる


# Draw 


# PANASONIC2020  Bishop  diff 224  (1024執筆)

解答遷移 WA AC

計 08:36

備考

➀　思考

ななめの動きは偶奇を変化させないことに注目して各行の該当マスをカウント　→ WA → 一マスも動けない場合を処理してAC





# 1017

# ZONE2021  Sign of Friendship   diff 

解答遷移　AC

計 16:56

備考

➀ 思考

小数をできるだけ扱いたくないので、gcdを用いるなどで整数の範囲で処理できないか考えたが思いつかなかったので、時間を無駄にしたのち、最終的には各障害物との直線の切片を全探索した。

➁ 補足 (傾き比較)

同じ傾きか否かの判定は gcd法 や 分母は払い法が有効だが、傾きの大小比較は素直に小数演算するしかなさそう


# ABC HHKB プログラミングコンテスト 2020 B   Futon  diff 102

解答遷移 AC

計 12:26

備考

➀ 思考

すべてのマスを全探索してカウントすればよいと判断。1マスしか進まないdfsを実装。

➁ 改善

4方向に進む実装を行ったが、一度探索したマスに戻る必要はない。したがって、seenで2方向(右、下)のみ進めばよく、これによってseenで探索済みのマスを管理する必要もなくなる。




# 228D  Linear Probing  diff 1035  (1026執筆)

解答遷移　WA RE * 5 AC

本番なら間に合ってない

備考

➀　思考

unionfindで Ah != -1 の場所を O(1)で求められると判断。親をグループの先頭にして、グループの数分アクセスする場所をずらせばよい　→ グループの先頭の定義を index　番目にあわせてしまうと、尾と先頭がつながっている状況に対応できないのでこの場合を別で処理する。find(h) と find(MOD-1) * 最後尾 が一致するかで この状況なのかを判定し、0 からいくつ後ろにアクセスするか求めることにした。一致しない場合は素直に親からグループ数だけ後ろにアクセスする。また、例えば 1 4, 1 5 の場合、4 と 5 が別のグループのままでは 1 4 で 6にアクセスすることができない。したがって、A[h]の値が確定したら h-1,h+1 とunionする必要がある。これらを完全に実装して完了

なお。unionfind find関数ではindex番号がそのまま帰るので、末尾の親を調べちたいからと言ってfind(-1)にすると -1 がそのまま帰ってきて条件分岐がバグるので注意

➁ 解法

まずアクセスしたい場所を親にすべきである。なぜなら親がもっともアクセスするのに適しているからである。したがって、A[h]が確定したら h+1 を親にすればよい。これならば既に h+1 が 既に親が x のグループに属していてもunionするだけで h の親が x になってくれる。さらに 末尾と先頭がつながっていても問題ない。 　

③　参考

https://hirohirohirohiros.hatenablog.com/entry/2022/03/05/000000



# 121D  XOR World  diff 1164

解答遷移 AC

計  1:11:26

備考

➀　思考

まず、A=5 B=7 とすると、f(5,7)=f(0,7)^f(0,4)になるので、f(0,A-1),f(0,B)を求めればいいことがわかった。制約的に探索するなら桁数を対象にしそうだな　→　桁数に注目しながら実験すると 1桁目 010101... 2桁目 001100110011..  3桁目 0000111100001111.. となり、規則性を検知。具体的には1桁目以外のi桁目では 2^(i-1) 個0が続いた後、0101010が繰り返されることになる。これを実装して完了


➁ 模範解答

ある偶数Aについて A^A+1=1になる。一桁目以外のすべての桁で数字が一致するからである。これによって例えばf(0,6)=1^1^1^6=7と求めることが可能



# 100B Ringo's Favorite Numbers diff 377

解答遷移 AC

計 06:26

備考

なし


# 161B Popular Vote  diff 102

解答遷移 AC

計 03:19

備考

なし



# 1018

# 091B  Two Colors Card Game   diff 319

解答遷移 AC

計 06:00

備考

なし

# 249D  Index Trio   diff  983

解答遷移 TLE AC

計 33:06 + 05:00

備考

➀　思考

まず i,j,kに大小関係の制約がないこと、i,j,kの値を求めるわけではないことから A の順序は自由に設定できることを把握。次に、A= 2 3 3 6 の場合、Aj=2,Ak=3,Ai=6　を満たす(i,j,k)の組み合わせの数は 2の個数* 3の個数 * 6の個数になることを理解　→ したがって Aの集合の2要素を全探索し、その積が集合内に存在すればそれらの個数の積を累積していけばよいと判断。→ あとはどうやって探索するかになるが、集合がもっとも大きいとき、つまり A=1,2,3,4,....2* 10^5 において、Aj=1 とすると 全ての範囲でkを考える必要がある。しかし j=2 のとき、Akは 1 ～10^5 までの 10^5個だけ調べればよく、(それ以上調べてもAj* Akを満たすAiは存在しないから) j=3になると 2/3 * 10^5 個　と合計で 2* 10^5 log (2* 10^5)回の処理で全探索可能なことがわかる。したがって Aの集合AAを取り、その要素を昇順に探索して、適切に処理をうち切れば O(AAの長さ 1og AAの長さ) で実行でき、これは十分高速なのでこれで完了できると判断。　→ TLE → Aiが要素として存在するのか集合内検索を行っていたつもりが、昇順処理したせいでAがリストに戻っていたためここで余計な処理を行っていたことに気づいて修正しAC



➁ 補足

kについて range(i,AAの長さ)としたため、jとkが異なるとき、個数の積を2倍する必要があった。j>kの場合を探索できないからである。しかし、kを1から探索した場合の計算量が O(NlogN)なので全く問題なくkを1から探索できる。

また、jとkを探索した結果 Ak* Aj がAの要素として含まれない場合をdcontinueしたが、この場合のAiの個数は0なので問題なく積を累積できる。


# 1019

# 133B Good Distance   diff 165  (1025 執筆)

解答遷移 AC

備考

➀ 思考

平方数をあらかじめ管理しておけば、全組み合わせの距離を調べて平方数であるか判定することでこの問題を解答できると考えた。



# ☆ 236D Dance 1190  (1025 執筆)
 
降参

備考

dfs 再復習


# 1020  
 
 # 158C Tax Increase  diff 174  (1024執筆)
 
 解答遷移 AC
 
 備考
 
 ➀ 思考
 
 整数の範囲で頑張りたい　→ 税抜き X 円の場合、108X//100 =A となるがこれを 100A<= 108X < 100A+100 と表現できるので100A ～ 100A+99まで探索し、108で割り切れる値が X の候補になる。これをBの場合でもためせばよい　→ A,Bは税込み価格ではなく、税の値であるのでこれを修正してAC
 
 ➁ 1024
 
 100A ～ 100A+99まで探索し、10B <= X < 10B+9を満たすならばその値が求めるべきX 
 
 ③ 別解
 
税抜き価格Xの満たす範囲は 0 ～ 100/0.08 なのでこの範囲で全探索すればよい

 



# 1021 

# 155C Poll  diff  236

解答遷移 AC

計 05:11

備考

➀ 思考

カウンターで個数を管理し、最頻値と個数が一致するものを昇順で出力すればよいと考え、カウンターのキーをソートしてそのvalueが最頻値に一致するか判定した。


# LUCKY PIN diff 838

解答遷移  TLE AC

計 49:36 + 05:00

備考

➀　思考

削除するのではなく、先頭から使うか使わないか選んで3桁作る方が良さそうだと判断。→ 1, 何番目か 2, 文字列候補　の情報ですべての遷移を把握できると判断。行に前からの番号、列に文字列(000～999)に対応する数字を与え、Trueに変えていこうとしたが、02　と 2 などで情報がうまく管理できなかった。 → これらの違いは桁数なので、3次元空間のaxis=0で桁数ごとに管理すればこの問題を解決できると判断。→ TLE → もうかなり時間も使っているし、ほかの案もないので、探索範囲を狭められないかと考察　→ 1桁目,2桁目に関して 0～999まで列を探索する必要がないことに気づき、dpの形状を適切に縮小修正せいてAC

➁　模範解答

暗証番号の候補は 000～999までの1000通りしかないので、これを全探索して作れるか判定すればよい。

候補全探索


# 138D Ki  diff 920

解答遷移 AC

計 24:39

備考

➀ 思考

累積和っぽいな～　→ リストで解こうとするが、さすがに枝分かれを表現するのがきびしい　→　根からbfsで探索し、次の根にポイントを累積していく処理をすればよいことに気づいてAC



# 085D KatanaThrower  diff 954

解答遷移 WA AC

計 28:35 + 05:00

備考

➀　思考

貪欲にとけそう。例えば a の最大値が7 のとき 10ダメージを出すならば必ず2回は刀を振る必要があり、 3+7 4+6 ...と刀の種類によって10ダメージの出し方は様々だが、7を2回降ること確実に10以上のダメージを与えられる。したがって任意のダメージ D を与えるための最小回数は D を a の最大値で割って切り上げた値になると判断。あとは投げる場合を考慮する必要があるが、この場合も a の最大値未満の b の刀を投げる必要は全くないので B を a の最大値で二分探索することでどの刀を投げるべきか求め、投げた後にもまだダメージを与える必要があるなら 最大の a での割り算を行う処理で十分だと判断　→ WA → 試行錯誤したコードの影響で、投げる途中でHを超える場合にそこで処理を終える部分がなくなってしまっていることに気づいて修正し、AC


➁ 補足

例えば、一度は振らないとその刀を投げられないような状況だと貪欲ではとけなそうだな

* 1028 追記

この設定が加わっても、a + b が　最大の a を下回るならその刀を投げる意味はないので貪欲でとけそう。

また、258D Trophy はこのような設定の問題だった。貪欲だった。


# 084D 2017-like Number  diff 980

解答遷移 AC

計 18:53

備考

➀ 思考

クエリが10^5なので、クエリごとの探索は無理。→ 1 ～ 10^5 までそれが2017に似ているかあらかじめ判定できれば、それを１して累積和を取ればクエリごとに O(1) で求められる。→ Xが2017に似ている場合には、X,(X+1)//2の両方が素数であるので、これらの素数判定ができればXが2017に似ているか判定できる。→ エラストテネスのふるいで 2* 10^5 までの素数をすべて求められるのでこれで解答できると判断　→　実装してAC



# 115D Christmas  diff 1088　　

解答遷移 AC

計 1:10:48

備考

➀ 思考

BBPPPBPB....のバーガーに対して、B=0,P=1として累積和を取ればX番目までのパティの数は簡単にわかるが、N=50では 10^20程度であって軽くメモリの限界を超えるためこの方針で解くことはできない。

→ 疲れていたこともあってなぜこの方針をとったか曖昧なのだが、i番目のバーガーを B Ni-1 P Ni-1 B とみて、Xが1ならばこれまで食べた数を出力して終了、ちょうど、i-1バーガー +1 ならこれまで食べた数 + Ni-1バーガーに含まれるパティの数 +1を出力して終了。N1-1バーガー +2(底と中間) 以上食べられるなら N1-iバーガーに含まれるパティの数+1を食べた数に追加し、XをN1-1バーガー+2だけ減らして、Ni-1バーガーをどれだけ食べられるか同じ処理を行えばよい。Ni-1バーガー食べられないなら、Xを1減らしてNi-1バーガーをどれだけ食べられるかに移る。

➁ 1026 整理

i+1　バーガーの構造は パティ 0,Pi,1,Pi,0  長さ 1,Li,1,L+i,1 になるので N-1番目までのパティと長さのそれぞれを管理すれば繰り返される状態のすべてを把握できることになる。→ X=1,Li+2 の場合、食べるパティの数がわかる。それ以外の場合は、X>Li+2 ならば食べた数を2+Pi ,Xを-2+Liして(X < 2+Li ならばなにもしない) Liのどこまで食べられるか Xを-1することで iバーガーの先頭から Xだけ食べる問題に置き換えることができる。これを食べる数が判明するまで or 0 バーガーになるまで繰り返せばよい。


# 134D Preparing Boxes  diff 926

解答遷移 AC

計 19:30

備考

➀　思考

Nにボールを入れるかどうかはAnにのみ依存するから、逆順で全探索して倍数を全部見れば良さそうだと判断。O(NlogN)なので探索自体は問題なく行えるのだが、Aiと状況が一致していなくてもボールを入れれば解決するので、逆に条件を満たさない状態がわからなかった。様々なコーナーケースを考察してみたものの、そういった状況に陥ることなど起こりえないと考えざるをえず、しぶしぶの提出　→ やっぱり自分の考察は正しく条件を満たさないことはないようでACとなった。


# 144C Walk on Multiplication Table  diff 320

解答遷移 AC

計 08:42

備考

➀　思考

XについてX=X1* X2 と表現した場合にX1+X2が最小になるX1とX2を求めることができれば答えは X1-1 + X2-1 になると判断　→ 約数列挙の関数をそれっぽく変更してAC


# ☆ 163D Sum of Large Numbers diff 163

解答遷移 AC

計 20:13

備考

まずこの問題は記録こそないが2回目。降参して復習していない状態でもう一度出会った。そこそこ記憶がある状態だったのでACできた感じ

➀　思考

10^100 を 10に置き換えて考えると、10+12+13 と 11+14 では一桁目が一致するものの足す個数の違いで2桁目が異なるため合計値が異なる。10^100は 1 ～ 10^5まで足し合わせても遠く及ばないほどの巨大数なので個数が異なれば必ず和も異なることになる。したがって、この問題では0 ～ N の範囲で K,K+1,...N+1 個の数を選ぶ場合に、それぞれの場合で何種類の和を作ることができるかという問題と解釈できると判断。→ 組み合わせで全探索することは不可能だが、例えば 3個選ぶ場合の和の最小値は 0+1+2 最大値は N-2+N-1+N になりこの間の数は全て和として表現できることに注目すると、最小和は K(K-1)//2 ,最大和は 累積和の要領で f(N)-f(N-k) * f(x) = 1～x までの連続数の和　として求められ、これによって和の個数が求まる。→ 選ぶ数を全探索して完了　→ AC


# ☆ 238D AND and SUM  diff 921   (1028 執筆)

降参

備考

➀　思考

bit演算らしく　S,a を後から順に探索して矛盾が生じないかで判定すればよいと考えた。これならば O(6* 10^6) 
なので十分高速　→ しかし繰り上げを考慮しても xi=0,yi=0 と x1=0,y1=1 において ai=0 であるが siは一位に定まらないことでこの処理で解答できないとわかり、代案もなく降参した

➁　解法

x + y = z とすると x and y <<1 + x xor y = z となる。x and y がx,yがともに1になる場所を返すことから
x + y <<1 は桁上がりする場所を返し、x xor y は 桁上がりしない　かつ　和が1 になる場所を返すからである。よって x xor y = s - a<<1 が成立する。ここで s - a<<1 >= 0 であり、 桁ごとの and と xor の出力は一致しないことから a and s-a<<1 = 0 が成立する。したがって、x,y が存在するための条件は s - a<<1 >= 0 、 a and s-a<<1 = 0 がともに成立することである。

③　参考

https://cocoinit23.com/abc238/




# 1022 

# 139B  Power Soket diff 123

解答遷移 AC

計 05:14

備考

なし



# 202D aab aba baa  diff 966

解答遷移 AC

計 19:00

備考

➀ 思考

K番目の文字列が、a で始まるグループか b で始まるグループかわかれば、1文字目から順に特定して行けそうだと判断。115Dの教訓を活かして再帰的に解く方針をとる　→ a が A 個、b が B 個の状態で aからはじまるものの個数は (A+B-1) C A-1 となる。これを高速に計算できれば、Kと比較して文字を特定できる　→ scipy.comb を60C30で試すとめっちゃ速かったので大乗だと判断。これをK=1になるまで繰り返して、最後に残った a と b について "a" * A + "b" * B とならべて足し合わせる　→ AC

➁ scipy.special.comb

調べたけど計算量はわからなかった。しかし今回170ms で実行できたことからabcでは問題なくACできそうだなと感じる。



# 126C Dice and Coin  diff 638

解答遷移 AC

計 15:59

備考

➀　思考

出目で全探索して、K未満の場合は何回連続表なら勝てるか二部探索で求めて確率を出し、K以上なら絶対勝つからそこでbreakする処理でできそう　→ AC



# ☆ 194D Jorney  diff 1078

降参

備考

➀　解法

![image](https://user-images.githubusercontent.com/109026838/197346687-6955b5b4-f1aa-40e2-9f62-10e643742522.png)

https://www.rimse.or.jp/research/past/pdf/4th/work10.pdf


まず回数の期待値なので、回数と確率が必要。そこで、k種類パスを張っている状況において未到達点が選ばれる回数をmとすると、E = m(k/n)^(m-1)* (1-k/n) になる。これ k=1 ～ N-1 の範囲で足し合わせると n(1+1/2+...1/n-1) になるので全探索して足し合わせれば完了


➁　追記

期待値の求め方がまったく分からず歯が立たなかったが、これで求め方を理解できた



# 274C Ameba  diff 315

解答遷移 AC

計 16:40

備考

➀　思考

親に子供を格納して、bfsしていけばよいと判断　→ AC



# 216D Pair of Balls  diff 1039

解答遷移 AC

計 46:31

備考

➀　思考

ボールの種類がNだから、queを使って筒の中を前から順に取り出すと全部調べ尽くしても O(2N)で十分。 → ただ取り出したボールがどの筒から取り出したものか記憶しておかないと、次に取り出すべき筒が分からなくなるので、長さNのボールリストにそのボールが取り出された筒の番号を格納していき、2個ボールが取り出せる状態になったらそのボールが取り出された筒を調べて新たなボールを取り出し、そこにその筒の番号を格納することにした。→ あとは筒が空になった場合の処理などを適切に施してAC


➁ 別解

サイクル






# 1026

134C Exception Handling  diff 136

解答遷移 WA AC

計 11:01 + 05:00

備考

➀　思考

Aのi番目を除いた最大値を素直に取ることはできないが、Sortset のdiscard なら O(2N√N)なので間に合う　→ サンプル2のような全ての要素が同じ場合に空になるためこれを別途処理する → WA → discard すると　1 2 2 のような場合に 2 2 2 にならない。→ カウンターで個数を管理し、Ai が重複していないならばdiscard , 重複しているならなにもしないで　A[0]を出力すればよいと判断　→ AC

* heapq と混ざって-1した要素をリストに格納しているがその必要は全くない

➁ 別解

1, 最大値を記憶して起き、Aiが最大値ならば降順に並べたリストの1番目を、そうでなければ0番目を出力

2, heapq で管理し、Aiが最大値ならばpop 先頭を出力 push そうでなければ先頭を出力する 

3, 



# 1028 

# 197D ORXOR   diff 809  2回目 

解答遷移 AC

計 28:56

備考

➀　思考

分け方を考えるのめんどくさそうだし、XORの性質で最適化する仕組みがわかりそうだな ( bit 演算の性質を学びたいと思ってこの問題に触れたこともあって) 　→ 全然わかんね → グループの分け方 bit全探索で探索できるくね? → N-1 個の 0 1 を生成して、1ならグループが異なるとしてリストに A[i+1] をappend。 0　なら 同じグループであるとして最後の要素 |= A[i+1] とすればリストにすべての区間の OR 演算値が格納される。最後に前から順にXOR をとればその分け方での解が求まるのでこれが最小値かどうか判定すればよい　→ AC













