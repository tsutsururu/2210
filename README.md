# 2210

# 1002

#  186A Brick   diff 4

解答遷移 AC

計 01:23

備考

なし



# ARC122B ☆  Insurance   diff 729　　

解答遷移 AC

計 23:00

備考

➀ 思考

さっぱりわからない。実験によってそれぞれ x= Ai/2b となる xで損失が極小になることはわかったので、B問題だし、極小値へのベクトルが平衡になる場所 x が全体を最小化するってことで解答できそうだと判断(全く根拠なし)。あとはN が 偶数の場合だけ、平衡地点が2か所あるのでそれを比較していい方をだせば完了だな AC

* この考えが正しいとしても、Aの中央地点を Ai, Aj とすると、 偶数のときは Ai < x <Aj でベクトルは平衡になるが、どちらかに一致する場合にはむしろ平衡ならないと気が付く。本当にたまたまのACである。ABCと勘違いしたためにできただけ


➁ 解法

Nx - Σmin(2x,Ai) のグラフの傾きを考えると、Nが偶数の場合、例えばN=4のときは A2/2 < x < A3/2 において傾きが0になって極小値をとることがわかる( min()が含まれるためなめらかではないので、A2/2 および A3/2 の前後で傾きが急変する) Nが奇数の場合傾きが0になることはないが、例えば N=3 の場合 A1/2 < x < A2/2 において 傾き -1 , A/2 < x <A3/2  において傾き 1になるので　その中間の A2/2 において 極小値をとる。

したがって、x = A[N//2] で損失は最小になる。 ( Nが偶数のときは A[N//2-1] ～ A[N//2] を満たす任意の実数がxとして成立する)


中央値とindex番号のズレに注意



# 182D Wandering  diff 708

解答遷移 AC

計 27:57

備考

➀ 思考

途中の情報が必要なので、塁積和をとって途中の情報を消したりはできない。[ 現在地 , 最高到達点 ] と2次元で保存しながら更新していくのがよいと考えた。あとはどうやってこれらを更新していくかで、現在地から次の現在地まで行くのは累積和で簡単に求まる。よって最高到達点の更新方法だが、これには場所だけでなく、進み方の情報も必要であることに注目した。例えば 現在の最高の進み方が +5 だとしたら現在地 + 5 が最高到達点であれば、最高到達地点を更新する。また、進み方も随時更新され、累積和が最高の進み方を超えれば更新していけばよい。あとは更新の順番に気を付けて実装してAC


実際には20分ぐらいで完了できていたのだが、手計算による検算がうまくいかず提出までに時間がかかってしまった。




# 平衡二分探索木　ver python の勉強

C++には存在し、pythonには存在しないデータ構造 std::set をpython で扱えるようになる。

https://qiita.com/tatyam/items/492c70ac4c955c055602





# ☆ 217C  Cutting Woods  diff 802

➀ 思考

長さ12の木材を位置7で切断したい場合、0,1,..,6  8,9,..,12 の2グループが生成される。これは最初に 0 始まり 長さ12 の木材を持っている状態で、0 始まり長さ7 , 8(7+1) 始まり長さ 5(12-7)の2グループが生成されたと考えられる。したがって、始点と長さを記憶していけばこの問題を解答できると考えたのだが、この次に 3 の位置で分断しようとした場合 位置3 がどのグループに含まれるかわからなければいけない。そのためには例えば始点を管理して二分探索するなどの方法が考えられるが、これにはこの操作を行う前に sort 処理を行わねばならず、全体で O(NlogN) かかるのでとてもクエリ全てをさばききれない。この 位置x がどの始点からはじまるグループに含まれるかのボトルネックを解消するには、おそらくこの処理に適したデータ構造が必要だと感じ、それを知らない今は降参するしかないと判断した。

結局 平衡二分探索木が必要だったので、思考自体は◎





























