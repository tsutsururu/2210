# 2210

# 1002

#  186A Brick   diff 4

解答遷移 AC

計 01:23

備考

なし



# ARC122B ☆  Insurance   diff 729　　

解答遷移 AC

計 23:00

備考

➀ 思考

さっぱりわからない。実験によってそれぞれ x= Ai/2b となる xで損失が極小になることはわかったので、B問題だし、極小値へのベクトルが平衡になる場所 x が全体を最小化するってことで解答できそうだと判断(全く根拠なし)。あとはN が 偶数の場合だけ、平衡地点が2か所あるのでそれを比較していい方をだせば完了だな AC

* この考えが正しいとしても、Aの中央地点を Ai, Aj とすると、 偶数のときは Ai < x <Aj でベクトルは平衡になるが、どちらかに一致する場合にはむしろ平衡ならないと気が付く。本当にたまたまのACである。ABCと勘違いしたためにできただけ


➁ 解法

Nx - Σmin(2x,Ai) のグラフの傾きを考えると、Nが偶数の場合、例えばN=4のときは A2/2 < x < A3/2 において傾きが0になって極小値をとることがわかる( min()が含まれるためなめらかではないので、A2/2 および A3/2 の前後で傾きが急変する) Nが奇数の場合傾きが0になることはないが、例えば N=3 の場合 A1/2 < x < A2/2 において 傾き -1 , A/2 < x <A3/2  において傾き 1になるので　その中間の A2/2 において 極小値をとる。

したがって、x = A[N//2] で損失は最小になる。 ( Nが偶数のときは A[N//2-1] ～ A[N//2] を満たす任意の実数がxとして成立する)


中央値とindex番号のズレに注意



# 182D Wandering  diff 708

解答遷移 AC

計 27:57

備考

➀ 思考

途中の情報が必要なので、塁積和をとって途中の情報を消したりはできない。[ 現在地 , 最高到達点 ] と2次元で保存しながら更新していくのがよいと考えた。あとはどうやってこれらを更新していくかで、現在地から次の現在地まで行くのは累積和で簡単に求まる。よって最高到達点の更新方法だが、これには場所だけでなく、進み方の情報も必要であることに注目した。例えば 現在の最高の進み方が +5 だとしたら現在地 + 5 が最高到達点であれば、最高到達地点を更新する。また、進み方も随時更新され、累積和が最高の進み方を超えれば更新していけばよい。あとは更新の順番に気を付けて実装してAC


実際には20分ぐらいで完了できていたのだが、手計算による検算がうまくいかず提出までに時間がかかってしまった。




# 平衡二分探索木(順序付き集合)　ver python の勉強

C++には存在し、pythonには存在しないデータ構造 std::set のpython版 Sortedsetを扱う

・概要

https://qiita.com/tatyam/items/492c70ac4c955c055602

・関数など

https://github.com/tatyam-prime/SortedSet


簡単に言えば、リストに追加した後、通常よりも高速にsortしてくれるデータ構造である。


S=Sorted(イテラブル)で初期化することで扱える。基本操作はリストと同じ。S[index]で index番号にアクセスして要素を取り出すことができる

・ add(x)

要素の追加。set同様、重複していれば追加されない

・ index(x)

x 未満の要素の数を出力できる。






# ☆ 217C  Cutting Woods  diff 802

➀ 思考

長さ12の木材を位置7で切断したい場合、0,1,..,6  8,9,..,12 の2グループが生成される。これは最初に 0 始まり 長さ12 の木材を持っている状態で、0 始まり長さ7 , 8(7+1) 始まり長さ 5(12-7)の2グループが生成されたと考えられる。したがって、始点と長さを記憶していけばこの問題を解答できると考えたのだが、この次に 3 の位置で分断しようとした場合 位置3 がどのグループに含まれるかわからなければいけない。そのためには例えば始点を管理して二分探索するなどの方法が考えられるが、これにはこの操作を行う前に sort 処理を行わねばならず、全体で O(NlogN) かかるのでとてもクエリ全てをさばききれない。この 位置x がどの始点からはじまるグループに含まれるかのボトルネックを解消するには、おそらくこの処理に適したデータ構造が必要だと感じ、それを知らない今は降参するしかないと判断した。

結局 平衡二分探索木が必要だったので、思考自体は◎


➁ 解法

7の木材の位置3で分断する際、 [0,3] [4,4] と考えたが、実は切れ込みの位置(位置0,7を含む) を管理さえすれば長さを管理しなくても、前後の要素の差でこれが求まる。　例えば 0,3,7 のとき、位置2を含む集合の長さは 3-0 で 3とわかるし、 位置5では 7-3=4 で長さが4とわかる。


③ 入力改善   input = sys.std.readline

仕組みはわからないが、これで提出時間が半分になった。これを宣言するだけであとは通常通りなので、大量の一行入力(for で処理するやつ) の場合は脳死で使った方が良さそう

https://qiita.com/kyuna/items/8ee8916c2f4e36321a1c




#  253c  Max - Min Query      diff  518

解答遷移 AC

計 17:00

備考

➀  思考

query3 に際して、最大値と最小値にアクセスする必要があるが、挿入される値は単調に増加したり減少したりしないので、今持っている値すべての順番を記憶しておかないと、高速なアクセスができない。挿入毎にsortするわけにもいかないので SortSet を使用することにした。しかし今回は同じ要素を個数を含めて管理しなければならず、SortMultiSetを使うのかなと考えたが、値の削除が面倒そうだったので、個数の管理は別でCollectionで行い、空になったらSortsetから削除するという処理を施せばよいと判断。 


➁　別解

https://atcoder.jp/contests/abc253/submissions/32056927

collections.Counter + 優先度付きキュー　で最先端の個数が0だったら、popする処理を繰り返すことで、最小値、最大値に高速にアクセスする。

注意点は２つ。一つは最小値だけでなく、最大値も必要なので 2つのheap構造が必要になること、また最大値をとりだすために、-xを格納しなければいけないこと。2つ目は、heappush(Xmin,値) として、明確に最小値 heap　と最大値 heapのどちらに値を格納するか示さなければならないこと。SortSetの方がはるかに楽



#  ☆  170D  Not Divisible   diff 1033

降参

備考

➀ 思考

Aiについて約数列挙し、Aにその約数が存在するか 積集合をもちいて判定する処理を考えた。最大計算量は 要素が 10^6 ～ 10^6-2.0* 10^5 のN個のときで、積分することでこれを求めると 1.8* 10^8 でギリギリ通せるかと判断して提出 TLE 。。。

なお普通に重複処理をうまく行えなかったようで　WA も出した。➁で示すように逐一積集合を求めずとも、約数全部をまとめて最後に検出すればこのWAは消えそうだ

➁ 解法

ポイントは以下2点

・列挙するなら 約数　より　倍数

A が B　の約数 ⇔  B は A の倍数 であることを利用する。前者は候補列挙に　√ Ai 回ループが必要で、後者は候補列挙に maxA / Ai 回のループが必要である。 ③でも述べるが、N要素における合計値 つまり積分した値は桁が1つ異なる程度に、後者の方が高速で処理できてしまう。 

・　重複処理

例えば A= 2 8 の場合、 8 のみが条件を満たすためには 列挙する倍数を 2Ai,3Ai...にする必要がある。Aiを含めてしまうとすべての要素が条件を満たしてしまうためである。 

しかしA= 2 2 8 の場合では2を含めないといけない。これを解決するために個数を管理して、最後の検出の際に、倍数候補に含まれない　かつ 重複する要素がないものを数えるようにしたらよいだろう。これならば A= 2,3,3,15,15 に対して 2は候補に含まれずただ一つなので、条件をみたし、3 は候補に含まれないが重複するので省かれる。15は候補に含まれるので数えらない。これで完了できる


③ log N   vs  √ N の積分

後者は結局 N ^ (3/2) になるため N= 10^6 とすると 10^9になるが、 logN はたかだか 10倍する程度なので処理性能が全く異なる。




# 1003  

# アルゴ式 データ構造

# 9-1  二分木の通りがけ順

備考

通りがけ順の定義通りに出力できるようにしたdfsを実装するだけ。具体的には子の情報を index番号か -1 で持つ。例えば [2,-1] で　左側に頂点 2の子を持ち、右側には子を持たないことを示すことにする。あとはふつうにdfsしつつ、右側の子方向に探索を始める前に自分自身の番号を保存すれば完了



# 9-2  二分探索木への挿入 (1)

解答遷移 WA WA AC 

計  09:19

備考

完全にsortされているものだと思っていたが、ルールに従い木を構築し、行きがけ順で出力すれば完了できる

・構築ルール

根頂点から順番に見ていき、
・挿入したいキーが今いる頂点のキー以下である場合は左側の子頂点へ進む
・挿入したいキーが今いる頂点のキーより大きい場合は右側の子頂点へ進む
という動作を繰り返します。
進む先の子頂点が存在しなくなったとき、
その場所に、挿入したいキーをもつ頂点を挿入します。


# 9-3 二分探索木への挿入 (2)




# 222A   Four Digits   diff 5

解答遷移　AC

計 01:08

備考

なし

# 221A Seismic magnitude scales   diff 10

解答遷移　AC

計 01:39

備考

なし

# 222A Find Multiple   diff 14

解答遷移 AC

計 05:19

備考

➀ 解法

B//C * C が B以下の最大のCの倍数なのでこれが A以上であれば出力し、そうでなければ-1 


# 068C  Cat Snuke and a Voyage  diff 609

解答遷移 AC

計 06:39

備考

➀ 思考

bfsで最短距離を調べ上げて、最後にNの最短距離が2かどうか判定




# 106C  To Infinity   diff 441

解答遷移 AC

計　12:47

備考

➀ 思考

5000兆 = 5* 10^18 。　2^60 ≓ 10^18 より 1以外の数がSの先頭にあれば K の値によらず その値が答えになる。したがって考慮すすべきは K が S の先頭に存在する1を示すか否かである。 これはSの先頭に存在する 1　の数をカウントしてその数が K 以上ならば 1が答えになり、それ以外であれば1の次に先頭に存在する数が答えになる処理で完了できると判断。

➁ 改善

K番目までSを前から全探索できないから、カウントするかとなったが、S全部をみる途中にK番目が存在すればそこまで見る処理はできるの。具体的には range(len(Sstr),K) とすればよい。



# 122C  Get AC   diff 700

解答遷移 WA AC

計 30:26

備考

➀　思考

クエリにO(1)で解答しなければいけないので、始点と終点にアクセスするだけでその区間におけるACの数を求めたい。よって尺取り法などではなく累積和を使うのが良さそうだと判断した。あとはSを前から順に探索し、文字列を構成していく。ACになればその地点の個数を+1して、それ以外なら文字列を空にしていく処理を行うことで完了できると判断。WA  →  何が間違っているのか見当もつかないし、愚直解も思いつかないので、ひたすらサンプル作ってテスト　→  運よくたまたますぐにカウントが正しくできていないケースを発見。 文字列が ACにならなければ空にしていたがこれでは AAC　がうまく処理できていなかったのだ。これを修正してAC



➁ 改善

Sの i文字目とi+1文字目で AC になっているか確認すればよい。



③ input.stdin.readline

![image](https://user-images.githubusercontent.com/109026838/193501818-3288c982-2503-4df5-a0fb-dedf78c61137.png)

文字列の場合だけそのまま読み込むと改行文字が含まれてしまうので修正が必要




#  ☆ 261D  Flipping and Bonus  diff 801

降参

備考

➀ 思考

dpだな。ただお金がでかすぎて2次元リストつくれない。それさえできればカウント数を追っていけば解けるのに。。。代案も見つからず降参



➁ 模範思考

i回目投げたとき Z 円持っていたとする。　すると i+1 回目に 裏が出れば Z 円のままであり、表が出ればZ + Xi+1 円になり、さらにここまでの連続表数 k がボーナス値ならばさらに Bk 円追加される。これがこの問題で生じる事象の遷移のすべてである。したがって、遷移を追うためには、1,今何回目なのか 2,何円持っているのか 3,何連続なのか の3つの情報が必要になる。ここで例えば 1,2 を行と列に、3を値としてdpすることも可能だが、サイズの制約で実装できない。そこで 1,3 を行と列にすれば実装できるなと判断して解答する

このdpにおける基本の思考の流れ、特に遷移状態を追うために何の情報が必要なのか把握することができていない。dpっぽいなー　→ こういうのいっつも回数お金の2次元リスト作ればいけるからそうしよー、とやってるから解けなかった。



# 248C Dice sum  2回目   diff  748

解答遷移 AC

備考

➀　思考

数列を構成する数列を前から順番に見ていくと 、i+1番目の数字は 1～M でかつ その数で総和を更新しても Kより大きくならない条件を満たすものである。したがって 1,　今前から何番目か 2,総和はいくつか　の情報を保持すれば遷移状態を追えることになる。また、総和、つまりK は K <= NM < 2500 なのでdpするための2次元リストを作ることは可能である。



# ☆ 197C ORXOR  diff 809

降参

備考

➀　思考

制約的にbit探索しそう。ただ、区間が2つとは限らないから違うのかな？　→ 最適化すると必ず2区間になるんだろうか？ 実験　→ １の偶奇で分類できそうだけど、複雑すぎてすべて追うのはきついし 2区間が最適かどうか結論づかない。 → 区間の数は最大でも N だからこれを全探索できないか？　→ でも 2つ以上箱作ってわけてくのきついしわかんねーな　降参

➁　解法

Aの要素間に仕切りを入れることで区間を表現すれば、仕切りを入れるかいれないかでbit全探索できる


③　反省

bit全探索は 2択の全探索　だから2区間が最適だと決めつけ、そうなることを示そうとし、時間も思考を浪費してしまった。いざ区間の数を探索しようとしたころには体力と思考力がなくなって十分な考察が行えず、解答もできなかった。


また仕切りで区間を表現することは便利なので反射的に思い付けるようにしたい


補足)

![image](https://user-images.githubusercontent.com/109026838/193567642-d6737281-325c-4271-824b-391519c9a19d.png)

この問題でも ^ と | を要素間に挿入し、 ^ ならば区間を区切り、 | ならば同じ区間とみなせばよい


# アルゴ式  dp 

# 1 最大和問題

解答遷移 AC

計 02:49

備考

➀　思考

bit全探索したいけど無理。 dpするにしても最大総和は目盛り的に無理だしな。。とりあえず実験。　→  普通に負の数無視すれば絵絵だけやん。実装　→　if 処理するのめんどいし、足して総和を更新しなかったら足さないをmaxで処理しよう　AC

* 結果的に意図せず dp になった

# 2 ナップサック問題

解答遷移 WA AC

計 15:34

備考

➀ 思考

dpしそうだし遷移状態を見る。 i+1番目の品物を選べるか否かは、i番目までの総和に依存する。また選んだ時の価値はi番目までの価値の総和とvi+1 になる。したがって、1,何番目か 2,それまでの重さの総和はいくつか、3,それまでの価値の総和はいくつか　の3つ情報で遷移状態を完全に把握出来る。価値の最大値を求めるので価値を要素にして更新していくのが良さそう。重さの最大値サイズのリストも作れるし。

* WA は選ばない処理を 選ぶ処理のif分の中に入れてしまったために生じた。選ばない方は一番先に処理してしまうのが良い。



# 3 部分和問題

解答遷移 AC

計 05:27

備考

➀　思考

bit全探索したいけど無理。実験 →　i+1 番目の処理は、i番目までの遷移に関係なく、選ぶ選ばないになってるな。1, 何番目か 2,それまでの総和　の2情報があれば遷移をすべて把握できるとわかる。求めるべきは総和Mになることがあるかどうかの存在確認なので、ある総和となる選び方があるかどうかFlagで管理するのが良さそう。Mもメモリを心配することのない小さな値である。



# 4 部分和数え上げ問題

解答遷移  AC

計 05:50

備考

全問と同じで、それに加えてその総和となる選び方の数も追いたいので、選び方の数を要素にすればよいと判断


# 5 最小個数部分和問題  

計 09:14

備考

baseは全問と同じ。あとは選んだ整数の数も把握したいので、選んだ数を要素で管理し、min処理すれば最小値がわかる。min理なので初期値はありえないでかい数を設定する


# 6  K 個以内部分和問題

備考

個数を管理し、K以下ならYes 


# 7 ☆  個数制限付き部分和問題

備考

➀　思考

遷移状態はこれまでと同じ。異なるのは同じ要素を重複して選べることだけだから、dp[i][j] が Trueなら dp[i+1][j+a[i]* k (<= b[i])] もTrueにする処理で良さそう。ただ計算量がとても気になる。例えば a=1 , b=10000 の場合は、True の要素 1つに対して 10000回消費するので、最高で O(NMb)になってTLEしてまうと思われる。→ 途中で一度でも Mになる選び方があればそこで打ち止めれば削減できそうだが、微妙。一応通すか　→ AC

➁　模範解答

dp[i][j] = i 番目までの整数の中から選んで総和を j とするときに含まれる A[i] の個数 とすることでこの問題を解答できる。jを前から探索して、 dp[i][j-a]<b なら まだ aを選ぶことができるので dp[i][j] = dp[i][j-a]+1 とできる。さらにdp[i+1][j]=0 になる。なぜなら i+1 番目までにおいて、a[i+1]を0個選んで総和 j にすることが確定しているからである。

* この問題ではそれぞれの個数にのみ制限があるので、このように解答できるが、もし個数の総数にも制限があったら例えば 個数の総数を管理するもう一つのdpを作成して同時に操作していくことで、一応解答できそう。つまり、Q6 とQ7を並行してやっていくイメージ



# 二分探索　勉強

単調性を持つ、または境界で真偽が2分する対象について、ある条件を満たす常に満たす範囲や境界の探索を行うアルゴリズム。

https://qiita.com/drken/items/97e37dd6143e33a64c8c#4-%E4%B8%80%E8%88%AC%E5%8C%96%E3%81%97%E3%81%9F%E4%BA%8C%E5%88%86%E6%8E%A2%E7%B4%A2%E3%81%AE%E9%81%A9%E7%94%A8%E4%BE%8B

探索範囲を (ng,ok] として mid = (ok+ng)/2　が 条件を満たす範囲に含まれるなら ok を更新し、そうでないなら ng を更新して、境界へ向かって条件を満たす範囲と、満たさない範囲を広げていく。最終的に境界を見つけることができれば、例えば条件を満たす最小値なら右端から広げてきた ok の値がこれを示し、条件を満たす最大値なら、左側から広げた ok の値がこれを示す。


https://www.forcia.com/blog/001434.html



# アルゴ式 二分探索

2-1 方程式を解く

解答遷移 AC

計 13:41


# 2-2 貯金 (1)

解答遷移 AC

計 12:27



# 2-3 最小の添え字

解答遷移 AC

計 05:40

備考

➀　思考

二分探索して A > B を満たすok 範囲 と満たさないng範囲を狭めていき、最終的に差が1になった瞬間全探索が終わり、ok範囲の最小値とはokそのものなのでそれを出力して完了

なお初期値は (ng,ok] のようにokは含めて、ngは含めないのがよいとみたので、ok=n-1,ng=-1とした。

![image](https://user-images.githubusercontent.com/109026838/193878360-993f6567-b1d2-4551-ac9f-9f195dee05bc.png)

****** 注意 *****

こんな雑に初期値を定めてはいけない

ok は条件を必ず満たす範囲であり、ngは条件を満たさない範囲である。たとえば A=[1] b=100　の場合 ok= 0 ( N-1 ) とはならない。なぜならA[0] = 1 > 100 とはならないからである。正しくは　ok=N ng=-1 とすべき。(ただしこの問題では A[-1]>b なので実は ok=N-1 としてもよい)



# 2-4 小さい数の個数

解答遷移  AC

計 09:36

備考

➀　解法

基本的には 2-3 と同じアルゴリズムであるが、 A < B の範囲を求めたいので、okを左側に設定する。また、Aのすべてが n より大きい、つまり条件を満たす範囲が存在しない場合を考慮して okの初期値は 配列外の -1 に設定する必要があることに注意。  









# 1004

# 224A Tiers diff 6

解答遷移 AC

計 01:23

備考

➀ 補足

name="tsuru" のとき name[-1000:]="tsuru" である。おそらく末尾と違って先頭は、0より前にアクセスしてもエラーにならず0にアクセスできるようだ。



# 225A  Distinct Strings  diff 12

解答遷移　AC

計 03:15

備考

➀ itertools.permuration

順列を生成。引数にはイテラブルとそこからいくつ取り出すかの情報が必要。返り値はその並び方。また、文字列も与えることができ、この問題はこの性質を利用することで簡単にとける


# 056C  Go Home  diff 731

解答遷移 AC

計 16:49

備考

➀　思考

dp。1, 時間　2,現在地 の2情報があれば遷移をすべて把握できる。しかし現在地をすべて管理するサイズのリストは作れない。 ほかに遷移に関わる情報を探す　　→  なし！！！　dp じゃないってこと？　実験　→ 時刻 t における最高到達点を Xt とすると、tまでに -Xt ～ Xt までのすべての地点に到達するルートがあることを確認。したがって、Xに最速で到達する時間とは、X<Xt を初めて満たす t となる。これは最高到達点の累積和を作成し、2分探索すればすぐに求まる。



# 245D  Polynomial division   diff 815

解答遷移 AC

計 42:03

備考

➀　思考

ややこしいから全部候補調べて、一致するの答える方針で行きたい。　→ B は最大 100項あり、係数は　-100 ～ 100 まで取りうるので 全探索する場合 約 O( 200^100 )かかるので絶対無理。実験してみる　→　はじめに B0が確定して、　次に ( C1 - B0 * A1 )  // A0 で B1 が求まる。　次は ( C2 - B0 * A2 - B1 * A1 ) // A0 にて B2 が確定する。　このように Bの係数は前から順に確定していき、その確定した値を利用して後の値も順に決まっていく。したがって Bを前から順に求めていけばよいと判断。 また、Bk を決定する際に B0 * Ak , B1 * Ak-1 ,....をいちいち計算するのは面倒なので、これらを Bi (0<= i <k) が確定した時点で随時計算してリストCC の　CCk　にでも累積しておくことで (Ck - CCk) //A0 で　O(1) 処理できると考え、これを実装してAC


➁　改善案 

そもそも Ck の 値 は Bk 計算時にしか使用しないので、CCなど作らなくても C の値を更新していっても全く問題ない。



# 　☆ 125D   Flipping Signs   diff 833

解答遷移 AC

計 1時間 over 絶対に本番で出てたら解けてない

備考

➀　思考

よくわからないので実験。　→ 前から順に決めていくと i+2 番目 に Ai+2 , -Ai+2 を選択することで Ai+2 が確定して i+1 番目までの総和も確定することがわかった。よって、1, 前から何番目か　2, i-2 番目までの総和   3,i+1 番目 が Ai+1 , -Ai+1 のどちらか　の3つの情報によってすべての遷移を把握できることがわかった。→ しかしAiにあわせたサイズのリストを作成することは不可能である。ここで例えば、 10(総和) - 4 - -8 の選び方と、 -10 - 4 - 8 の選び方は以降同じ遷移をし、必ず後者の総和が大きくなるので、この時点で前者を捨てることが可能なのですべての総和を記録する必要がないとわかる。よって行には番号、列にはAiの正負(つまりサイズ2) を割り振ったリストで要素(総和)を更新するdpを行えばよいと判断。

ここまでの考察にも時間がかったが、さらにここから index番号と、遷移の連動がうまくできず死ぬほど時間をかけてなんとかACできた


➁　考え方整理

まず i+2 番目に Ai+2 , -Ai+2 を選択した時点で i+1番目までの総和は確定するので、 -1ずらして考え、i+1番目の選択で i番目までの総和が決定すると考えてよい。するとdpにおける、i行目の処理は Ai+1 を選択し、i番目までの総和を確定する処理であることを理解しやすい。また、2番目,N番目を決定する際の処理が、3 ～ N-1 のmax処理と同様に行えないことに注意。


③ 別解

- が偶数ならば必ず全て正の数にでき、奇数なら任意の一か所を選んでそれ以外すべてを正の数にできる性質を利用








