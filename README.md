# 2210

# 1002

#  186A Brick   diff 4

解答遷移 AC

計 01:23

備考

なし



# ARC122B ☆  Insurance   diff 729　　

解答遷移 AC

計 23:00

備考

➀ 思考

さっぱりわからない。実験によってそれぞれ x= Ai/2b となる xで損失が極小になることはわかったので、B問題だし、極小値へのベクトルが平衡になる場所 x が全体を最小化するってことで解答できそうだと判断(全く根拠なし)。あとはN が 偶数の場合だけ、平衡地点が2か所あるのでそれを比較していい方をだせば完了だな AC

* この考えが正しいとしても、Aの中央地点を Ai, Aj とすると、 偶数のときは Ai < x <Aj でベクトルは平衡になるが、どちらかに一致する場合にはむしろ平衡ならないと気が付く。本当にたまたまのACである。ABCと勘違いしたためにできただけ


➁ 解法

Nx - Σmin(2x,Ai) のグラフの傾きを考えると、Nが偶数の場合、例えばN=4のときは A2/2 < x < A3/2 において傾きが0になって極小値をとることがわかる( min()が含まれるためなめらかではないので、A2/2 および A3/2 の前後で傾きが急変する) Nが奇数の場合傾きが0になることはないが、例えば N=3 の場合 A1/2 < x < A2/2 において 傾き -1 , A/2 < x <A3/2  において傾き 1になるので　その中間の A2/2 において 極小値をとる。

したがって、x = A[N//2] で損失は最小になる。 ( Nが偶数のときは A[N//2-1] ～ A[N//2] を満たす任意の実数がxとして成立する)


中央値とindex番号のズレに注意



# 182D Wandering  diff 708

解答遷移 AC

計 27:57

備考

➀ 思考

途中の情報が必要なので、塁積和をとって途中の情報を消したりはできない。[ 現在地 , 最高到達点 ] と2次元で保存しながら更新していくのがよいと考えた。あとはどうやってこれらを更新していくかで、現在地から次の現在地まで行くのは累積和で簡単に求まる。よって最高到達点の更新方法だが、これには場所だけでなく、進み方の情報も必要であることに注目した。例えば 現在の最高の進み方が +5 だとしたら現在地 + 5 が最高到達点であれば、最高到達地点を更新する。また、進み方も随時更新され、累積和が最高の進み方を超えれば更新していけばよい。あとは更新の順番に気を付けて実装してAC


実際には20分ぐらいで完了できていたのだが、手計算による検算がうまくいかず提出までに時間がかかってしまった。




# 平衡二分探索木(順序付き集合)　ver python の勉強

C++には存在し、pythonには存在しないデータ構造 std::set のpython版 Sortedsetを扱う

・概要

https://qiita.com/tatyam/items/492c70ac4c955c055602

・関数など

https://github.com/tatyam-prime/SortedSet


簡単に言えば、リストに追加した後、通常よりも高速にsortしてくれるデータ構造である。


S=Sorted(イテラブル)で初期化することで扱える。基本操作はリストと同じ。S[index]で index番号にアクセスして要素を取り出すことができる

・ add(x)

要素の追加。set同様、重複していれば追加されない

・ index(x)

x 未満の要素の数を出力できる。






# ☆ 217C  Cutting Woods  diff 802

➀ 思考

長さ12の木材を位置7で切断したい場合、0,1,..,6  8,9,..,12 の2グループが生成される。これは最初に 0 始まり 長さ12 の木材を持っている状態で、0 始まり長さ7 , 8(7+1) 始まり長さ 5(12-7)の2グループが生成されたと考えられる。したがって、始点と長さを記憶していけばこの問題を解答できると考えたのだが、この次に 3 の位置で分断しようとした場合 位置3 がどのグループに含まれるかわからなければいけない。そのためには例えば始点を管理して二分探索するなどの方法が考えられるが、これにはこの操作を行う前に sort 処理を行わねばならず、全体で O(NlogN) かかるのでとてもクエリ全てをさばききれない。この 位置x がどの始点からはじまるグループに含まれるかのボトルネックを解消するには、おそらくこの処理に適したデータ構造が必要だと感じ、それを知らない今は降参するしかないと判断した。

結局 平衡二分探索木が必要だったので、思考自体は◎


➁ 解法

7の木材の位置3で分断する際、 [0,3] [4,4] と考えたが、実は切れ込みの位置(位置0,7を含む) を管理さえすれば長さを管理しなくても、前後の要素の差でこれが求まる。　例えば 0,3,7 のとき、位置2を含む集合の長さは 3-0 で 3とわかるし、 位置5では 7-3=4 で長さが4とわかる。


③ 入力改善   input = sys.std.readline

仕組みはわからないが、これで提出時間が半分になった。これを宣言するだけであとは通常通りなので、大量の一行入力(for で処理するやつ) の場合は脳死で使った方が良さそう

https://qiita.com/kyuna/items/8ee8916c2f4e36321a1c




#  253c  Max - Min Query      diff  518

解答遷移 AC

計 17:00

備考

➀  思考

query3 に際して、最大値と最小値にアクセスする必要があるが、挿入される値は単調に増加したり減少したりしないので、今持っている値すべての順番を記憶しておかないと、高速なアクセスができない。挿入毎にsortするわけにもいかないので SortSet を使用することにした。しかし今回は同じ要素を個数を含めて管理しなければならず、SortMultiSetを使うのかなと考えたが、値の削除が面倒そうだったので、個数の管理は別でCollectionで行い、空になったらSortsetから削除するという処理を施せばよいと判断。 


➁　別解

https://atcoder.jp/contests/abc253/submissions/32056927

collections.Counter + 優先度付きキュー　で最先端の個数が0だったら、popする処理を繰り返すことで、最小値、最大値に高速にアクセスする。

注意点は２つ。一つは最小値だけでなく、最大値も必要なので 2つのheap構造が必要になること、また最大値をとりだすために、-xを格納しなければいけないこと。2つ目は、heappush(Xmin,値) として、明確に最小値 heap　と最大値 heapのどちらに値を格納するか示さなければならないこと。SortSetの方がはるかに楽



#  ☆  170D  Not Divisible   diff 1033

降参

備考

➀ 思考

Aiについて約数列挙し、Aにその約数が存在するか 積集合をもちいて判定する処理を考えた。最大計算量は 要素が 10^6 ～ 10^6-2.0* 10^5 のN個のときで、積分することでこれを求めると 1.8* 10^8 でギリギリ通せるかと判断して提出 TLE 。。。

なお普通に重複処理をうまく行えなかったようで　WA も出した。➁で示すように逐一積集合を求めずとも、約数全部をまとめて最後に検出すればこのWAは消えそうだ

➁ 解法

ポイントは以下2点

・列挙するなら 約数　より　倍数

A が B　の約数 ⇔  B は A の倍数 であることを利用する。前者は候補列挙に　√ Ai 回ループが必要で、後者は候補列挙に maxA / Ai 回のループが必要である。 ③でも述べるが、N要素における合計値 つまり積分した値は桁が1つ異なる程度に、後者の方が高速で処理できてしまう。 

・　重複処理

例えば A= 2 8 の場合、 8 のみが条件を満たすためには 列挙する倍数を 2Ai,3Ai...にする必要がある。Aiを含めてしまうとすべての要素が条件を満たしてしまうためである。 

しかしA= 2 2 8 の場合では2を含めないといけない。これを解決するために個数を管理して、最後の検出の際に、倍数候補に含まれない　かつ 重複する要素がないものを数えるようにしたらよいだろう。これならば A= 2,3,3,15,15 に対して 2は候補に含まれずただ一つなので、条件をみたし、3 は候補に含まれないが重複するので省かれる。15は候補に含まれるので数えらない。これで完了できる


③ log N   vs  √ N の積分

後者は結局 N ^ (3/2) になるため N= 10^6 とすると 10^9になるが、 logN はたかだか 10倍する程度なので処理性能が全く異なる。




# 1003  

# アルゴ式 データ構造

# 9-1  二分木の通りがけ順

備考

通りがけ順の定義通りに出力できるようにしたdfsを実装するだけ。具体的には子の情報を index番号か -1 で持つ。例えば [2,-1] で　左側に頂点 2の子を持ち、右側には子を持たないことを示すことにする。あとはふつうにdfsしつつ、右側の子方向に探索を始める前に自分自身の番号を保存すれば完了



# 9-2  二分探索木への挿入 (1)

解答遷移 WA WA AC 

計  09:19

備考

完全にsortされているものだと思っていたが、ルールに従い木を構築し、行きがけ順で出力すれば完了できる

・構築ルール

根頂点から順番に見ていき、
・挿入したいキーが今いる頂点のキー以下である場合は左側の子頂点へ進む
・挿入したいキーが今いる頂点のキーより大きい場合は右側の子頂点へ進む
という動作を繰り返します。
進む先の子頂点が存在しなくなったとき、
その場所に、挿入したいキーをもつ頂点を挿入します。


# 9-3 二分探索木への挿入 (2)




# 222A   Four Digits   diff 5

解答遷移　AC

計 01:08

備考

なし

# 221A Seismic magnitude scales   diff 10

解答遷移　AC

計 01:39

備考

なし

# 222A Find Multiple   diff 14

解答遷移 AC

計 05:19

備考

➀ 解法

B//C * C が B以下の最大のCの倍数なのでこれが A以上であれば出力し、そうでなければ-1 


# 068C  Cat Snuke and a Voyage  diff 609

解答遷移 AC

計 06:39

備考

➀ 思考

bfsで最短距離を調べ上げて、最後にNの最短距離が2かどうか判定




# 106C  To Infinity   diff 441

解答遷移 AC

計　12:47

備考

➀ 思考

5000兆 = 5* 10^18 。　2^60 ≓ 10^18 より 1以外の数がSの先頭にあれば K の値によらず その値が答えになる。したがって考慮すすべきは K が S の先頭に存在する1を示すか否かである。 これはSの先頭に存在する 1　の数をカウントしてその数が K 以上ならば 1が答えになり、それ以外であれば1の次に先頭に存在する数が答えになる処理で完了できると判断。

➁ 改善

K番目までSを前から全探索できないから、カウントするかとなったが、S全部をみる途中にK番目が存在すればそこまで見る処理はできるの。具体的には range(len(Sstr),K) とすればよい。



# 122C  Get AC   diff 700

解答遷移 WA AC

計 30:26

備考

➀　思考

クエリにO(1)で解答しなければいけないので、始点と終点にアクセスするだけでその区間におけるACの数を求めたい。よって尺取り法などではなく累積和を使うのが良さそうだと判断した。あとはSを前から順に探索し、文字列を構成していく。ACになればその地点の個数を+1して、それ以外なら文字列を空にしていく処理を行うことで完了できると判断。WA  →  何が間違っているのか見当もつかないし、愚直解も思いつかないので、ひたすらサンプル作ってテスト　→  運よくたまたますぐにカウントが正しくできていないケースを発見。 文字列が ACにならなければ空にしていたがこれでは AAC　がうまく処理できていなかったのだ。これを修正してAC



➁ 改善

Sの i文字目とi+1文字目で AC になっているか確認すればよい。



③ input.stdin.readline

![image](https://user-images.githubusercontent.com/109026838/193501818-3288c982-2503-4df5-a0fb-dedf78c61137.png)

文字列の場合だけそのまま読み込むと改行文字が含まれてしまうので修正が必要




#  ☆ 261D  Flipping and Bonus  diff 801

降参

備考

➀ 思考

dpだな。ただお金がでかすぎて2次元リストつくれない。それさえできればカウント数を追っていけば解けるのに。。。代案も見つからず降参



➁ 模範思考

i回目投げたとき Z 円持っていたとする。　すると i+1 回目に 裏が出れば Z 円のままであり、表が出ればZ + Xi+1 円になり、さらにここまでの連続表数 k がボーナス値ならばさらに Bk 円追加される。これがこの問題で生じる事象の遷移のすべてである。したがって、遷移を追うためには、1,今何回目なのか 2,何円持っているのか 3,何連続なのか の3つの情報が必要になる。ここで例えば 1,2 を行と列に、3を値としてdpすることも可能だが、サイズの制約で実装できない。そこで 1,3 を行と列にすれば実装できるなと判断して解答する

このdpにおける基本の思考の流れ、特に遷移状態を追うために何の情報が必要なのか把握することができていない。dpっぽいなー　→ こういうのいっつも回数お金の2次元リスト作ればいけるからそうしよー、とやってるから解けなかった。



# 248C Dice sum  2回目   diff  748

解答遷移 AC

備考

➀　思考

数列を構成する数列を前から順番に見ていくと 、i+1番目の数字は 1～M でかつ その数で総和を更新しても Kより大きくならない条件を満たすものである。したがって 1,　今前から何番目か 2,総和はいくつか　の情報を保持すれば遷移状態を追えることになる。また、総和、つまりK は K <= NM < 2500 なのでdpするための2次元リストを作ることは可能である。



# ☆ 197C ORXOR  diff 809

降参

備考

➀　思考

制約的にbit探索しそう。ただ、区間が2つとは限らないから違うのかな？　→ 最適化すると必ず2区間になるんだろうか？ 実験　→ １の偶奇で分類できそうだけど、複雑すぎてすべて追うのはきついし 2区間が最適かどうか結論づかない。 → 区間の数は最大でも N だからこれを全探索できないか？　→ でも 2つ以上箱作ってわけてくのきついしわかんねーな　降参

➁　解法

Aの要素間に仕切りを入れることで区間を表現すれば、仕切りを入れるかいれないかでbit全探索できる


③　反省

bit全探索は 2択の全探索　だから2区間が最適だと決めつけ、そうなることを示そうとし、時間も思考を浪費してしまった。いざ区間の数を探索しようとしたころには体力と思考力がなくなって十分な考察が行えず、解答もできなかった。


また仕切りで区間を表現することは便利なので反射的に思い付けるようにしたい


補足)

![image](https://user-images.githubusercontent.com/109026838/193567642-d6737281-325c-4271-824b-391519c9a19d.png)

この問題でも ^ と | を要素間に挿入し、 ^ ならば区間を区切り、 | ならば同じ区間とみなせばよい


# アルゴ式  dp 

# 1 最大和問題

解答遷移 AC

計 02:49

備考

➀　思考

bit全探索したいけど無理。 dpするにしても最大総和は目盛り的に無理だしな。。とりあえず実験。　→  普通に負の数無視すれば絵絵だけやん。実装　→　if 処理するのめんどいし、足して総和を更新しなかったら足さないをmaxで処理しよう　AC

* 結果的に意図せず dp になった

# 2 ナップサック問題

解答遷移 WA AC

計 15:34

備考

➀ 思考

dpしそうだし遷移状態を見る。 i+1番目の品物を選べるか否かは、i番目までの総和に依存する。また選んだ時の価値はi番目までの価値の総和とvi+1 になる。したがって、1,何番目か 2,それまでの重さの総和はいくつか、3,それまでの価値の総和はいくつか　の3つ情報で遷移状態を完全に把握出来る。価値の最大値を求めるので価値を要素にして更新していくのが良さそう。重さの最大値サイズのリストも作れるし。

* WA は選ばない処理を 選ぶ処理のif分の中に入れてしまったために生じた。選ばない方は一番先に処理してしまうのが良い。



# 3 部分和問題

解答遷移 AC

計 05:27

備考

➀　思考

bit全探索したいけど無理。実験 →　i+1 番目の処理は、i番目までの遷移に関係なく、選ぶ選ばないになってるな。1, 何番目か 2,それまでの総和　の2情報があれば遷移をすべて把握できるとわかる。求めるべきは総和Mになることがあるかどうかの存在確認なので、ある総和となる選び方があるかどうかFlagで管理するのが良さそう。Mもメモリを心配することのない小さな値である。



# 4 部分和数え上げ問題

解答遷移  AC

計 05:50

備考

➀ 思考

全問と同じで、それに加えてその総和となる選び方の数も追いたいので、選び方の数を要素にすればよいと判断


# 二分探索　勉強

・base 

メモ

条件を満たす範囲の探索

left とrigjht を中央値と交換しながら最お手ｋぃか

logN なので拘束



・応用

めぐる指揮

left , right をok,ng にして缶旅客化





# アルゴ式 二分探索

2-1 方程式を解く

解答遷移 AC

計 13:41














